{% extends "base.html" %}

{% block title %}Disc Review - Amphigory{% endblock %}

{% block content %}
<div class="disc-review">
    <header class="page-header">
        <h1>Disc Review</h1>
        <p class="subtitle" id="disc-status-text">Loading...</p>
    </header>

    <section class="scan-section card" id="scan-section">
        <div id="scan-status">
            <p class="text-muted">Checking for disc...</p>
        </div>
    </section>

    <section class="disc-info card" id="disc-info-section" style="display: none;">
        <h3>Disc Information</h3>
        <div class="form-row">
            <label for="disc-title">Title:</label>
            <div style="display: flex; gap: 0.5rem; flex: 1;">
                <input type="text" id="disc-title" name="disc_title"
                       class="setting-input" placeholder="Enter disc title">
                <button type="button" class="btn btn-small" onclick="searchTMDB()">Search TMDB</button>
            </div>
        </div>
        <div id="tmdb-results" class="tmdb-results" style="display: none;">
            <!-- TMDB results populated via JavaScript -->
        </div>
        <div class="form-row">
            <label for="disc-year">Year:</label>
            <input type="number" id="disc-year" name="disc_year"
                   class="setting-input setting-input-small" placeholder="YYYY"
                   min="1900" max="2100">
            <button type="button" class="btn btn-secondary" id="save-disc-info-btn" onclick="saveDiscInfo()" disabled>
                Save Disc Info
            </button>
        </div>
        <div class="form-row" id="metadata-links-row" style="display: none;">
            <label>Metadata:</label>
            <div id="metadata-links">
                <!-- Populated by JS: TMDB link | IMDB link -->
            </div>
        </div>
        <div class="form-row">
            <label></label>
            <button type="button" class="btn btn-small" onclick="setTrackNames()">Set Track Names</button>
        </div>
    </section>

    <section class="tracks-section card" id="tracks-section" style="display: none;">
        <div class="tracks-header">
            <h2>Tracks</h2>
            <div class="track-actions">
                <button type="button" class="btn btn-small" onclick="selectMain()">Select Main Feature</button>
            </div>
        </div>

        <form id="rip-form" onsubmit="submitRipTasks(event)">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-drag"></th>
                        <th class="col-select"><input type="checkbox" id="select-all-checkbox" onchange="toggleAll(this)"></th>
                        <th class="col-track">#</th>
                        <th class="col-duration">Duration</th>
                        <th class="col-size">Size</th>
                        <th class="col-resolution">Resolution</th>
                        <th class="col-preset">Transcoding Preset</th>
                        <th class="col-type">Type</th>
                        <th class="col-name">Track Name</th>
                        <th class="col-audio">Audio</th>
                        <th class="col-subs">Subs</th>
                    </tr>
                </thead>
                <tbody id="tracks-body">
                    <!-- Tracks populated via JavaScript -->
                </tbody>
            </table>

            <div class="rip-options">
                <div class="option-row">
                    <label for="output-dir">Output Directory:</label>
                    <input type="text" id="output-dir" name="output_dir" value="" class="setting-input" placeholder="Loading...">
                </div>
            </div>

            <div class="form-actions">
                <button type="submit" class="btn btn-primary" id="rip-button" disabled>
                    Process Selected Tracks
                </button>
                <span class="selected-count" id="selected-count">0 tracks selected</span>
            </div>
        </form>
    </section>
</div>

<script>
let scanResult = null;
let draggedRow = null;
let presetData = null;

// HTML escaping to prevent XSS
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Plex naming helper functions (mirror Python naming.py logic)
// Note: Plex suffixes removed - extras go in subdirectories so suffixes are redundant

function sanitizeFilename(name) {
    // Check for null/undefined
    if (!name) return '';

    // Remove invalid filename characters
    const invalidChars = '<>:"/\\|?*';
    let result = name;
    for (const char of invalidChars) {
        result = result.split(char).join('');
    }
    return result;
}

function generateTrackFilename(trackType, movieTitle, year, trackName, language) {
    // Check for null/undefined inputs
    if (!movieTitle || !year || !trackName) {
        console.error('Missing required parameters for generateTrackFilename');
        return 'unknown.mkv';
    }

    // Sanitize inputs
    const sanitizedTitle = sanitizeFilename(movieTitle);
    const sanitizedTrackName = sanitizeFilename(trackName);

    // Main feature naming
    if (trackType === 'main_feature') {
        // Check if this is an alternate language version (not en/en-us/english)
        if (language && !['en', 'en-us', 'english'].includes(language.toLowerCase())) {
            return `${sanitizedTitle} (${year}) - ${language}.mkv`;
        } else {
            return `${sanitizedTitle} (${year}).mkv`;
        }
    }

    // Extras naming: "Track Name.mkv" (no suffix needed since extras go in subdirectories)
    return `${sanitizedTrackName}.mkv`;
}

// Preset management
let presetsLoadedPromise = null;

async function loadPresets() {
    try {
        const response = await fetch('/api/presets');
        if (response.ok) {
            presetData = await response.json();
            console.log('Presets loaded:', presetData);
        } else {
            console.error('Failed to load presets:', response.status);
        }
    } catch (error) {
        console.error('Error loading presets:', error);
    }
}

function populateAllPresetDropdowns() {
    if (!presetData || !scanResult || !scanResult.tracks) return;

    document.querySelectorAll('.preset-select').forEach((select, index) => {
        const track = scanResult.tracks[index];
        if (track) {
            populatePresetDropdown(select, track.resolution);
        }
    });
}

function getRecommendedPreset(resolution) {
    // Parse resolution and recommend based on dimensions
    if (!resolution) return 'dvd';

    const match = resolution.match(/(\d+)x(\d+)/);
    if (!match) return 'dvd';

    const width = parseInt(match[1]);
    const height = parseInt(match[2]);

    // Same logic as preset_selector.py
    if (width >= 3840 || height >= 2160) return 'uhd';
    if (width >= 1920 || height >= 1080) return 'bluray';
    return 'dvd';
}

function populatePresetDropdown(selectElement, trackResolution) {
    if (!presetData) return;

    const recommendedCategory = getRecommendedPreset(trackResolution);
    // Try both "uhd" and "uhd4k" for UHD content
    const activePreset = presetData.active[recommendedCategory] ||
                         presetData.active[recommendedCategory + '4k'];

    selectElement.innerHTML = presetData.presets.map(preset => {
        const selected = preset.name === activePreset ? ' selected' : '';
        return `<option value="${escapeHtml(preset.name)}"${selected}>${escapeHtml(preset.name)}</option>`;
    }).join('');
}

// Drag and drop handlers
function handleDragStart(e) {
    // Clear any stale drag state (e.g., from cancelled drags)
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
    }
    draggedRow = e.target.closest('tr');
    if (draggedRow && draggedRow.classList.contains('track-row')) {
        draggedRow.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const targetRow = e.target.closest('tr');
    if (targetRow && targetRow !== draggedRow && targetRow.classList.contains('track-row')) {
        const tbody = targetRow.parentNode;
        const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
        const draggedIdx = rows.indexOf(draggedRow);
        const targetIdx = rows.indexOf(targetRow);

        if (draggedIdx >= 0 && targetIdx >= 0) {
            if (draggedIdx < targetIdx) {
                targetRow.after(draggedRow);
            } else {
                targetRow.before(draggedRow);
            }
        }
    }
}

function handleDrop(e) {
    e.preventDefault();
}

function handleDragEnd(e) {
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
        draggedRow = null;
        updateTrackOrder();
    }
}

function updateTrackOrder() {
    // Update scanResult.tracks to match new DOM order
    const tbody = document.getElementById('tracks-body');
    if (!tbody || !scanResult || !scanResult.tracks) return;

    const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
    const newOrder = [];

    for (const row of rows) {
        const input = row.querySelector('input[name="tracks"]');
        if (!input) continue;

        const trackNum = parseInt(input.value);
        if (isNaN(trackNum)) continue;

        const track = scanResult.tracks.find(t => t.number === trackNum);
        if (track) newOrder.push(track);
    }

    if (newOrder.length > 0) {
        scanResult.tracks = newOrder;
    }
}

// Check disc status and show scan button
async function checkDiscStatus() {
    try {
        const response = await fetch('/api/disc/status');
        const data = await response.json();

        const statusText = document.getElementById('disc-status-text');
        const scanSection = document.getElementById('scan-section');

        if (data.has_disc) {
            // Check if we have cached scan results in memory
            try {
                const scanResponse = await fetch('/api/disc/current-scan');
                if (scanResponse.ok) {
                    scanResult = await scanResponse.json();
                    displayScanResult(scanResult);
                    return;
                }
            } catch (err) {
                // No cached scan in memory - check database by fingerprint
            }

            // Check if disc is known in database by fingerprint
            try {
                const lookupResponse = await fetch('/api/disc/lookup-fingerprint');
                if (lookupResponse.ok) {
                    const discInfo = await lookupResponse.json();
                    if (discInfo.scan_data) {
                        // Show option to use cached scan or rescan
                        statusText.textContent = `Known disc: ${discInfo.title}`;
                        const scannedDate = discInfo.scanned_at ? new Date(discInfo.scanned_at).toLocaleDateString() : 'previously';
                        scanSection.innerHTML = `
                            <p class="text-muted">Previously scanned on ${scannedDate}</p>
                            <button class="btn btn-primary" onclick="loadCachedScan()">
                                Load Previous Scan
                            </button>
                            <button class="btn btn-secondary" onclick="startScan()" style="margin-left: 0.5rem;">
                                Rescan Disc
                            </button>
                        `;
                        // Store disc info for later use
                        window.knownDiscInfo = discInfo;
                        return;
                    }
                }
            } catch (err) {
                // Disc not in database - continue to show scan button
            }

            // No cached scan - show scan button
            statusText.textContent = `Disc: ${data.volume_name || 'Unknown'} (${data.device_path})`;
            scanSection.innerHTML = `
                <button class="btn btn-primary" onclick="startScan()">
                    Scan Disc
                </button>
                <span class="text-muted" style="margin-left: 1rem;">Click to analyze disc contents</span>
            `;
        } else {
            statusText.textContent = 'No disc detected';
            scanSection.innerHTML = `
                <p class="text-muted">Insert a disc and click refresh to scan.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Refresh</button>
            `;

            // Clear scan result and hide sections
            scanResult = null;
            document.getElementById('disc-info-section').style.display = 'none';
            document.getElementById('tracks-section').style.display = 'none';
        }
    } catch (error) {
        console.error('Error checking disc status:', error);
        document.getElementById('disc-status-text').textContent = 'Error checking disc status';
    }
}

// Load cached scan data from database
function loadCachedScan() {
    if (!window.knownDiscInfo || !window.knownDiscInfo.scan_data) {
        console.error('No cached scan data available');
        return;
    }

    scanResult = window.knownDiscInfo.scan_data;
    displayScanResult(scanResult);
}

// Start a scan
async function startScan() {
    const scanSection = document.getElementById('scan-section');
    scanSection.innerHTML = `
        <div class="scanning">
            <div class="spinner"></div>
            <p>Scanning disc...</p>
        </div>
    `;

    try {
        const response = await fetch('/api/disc/scan', { method: 'POST' });
        const data = await response.json();

        // Poll for results
        pollForScanResult(data.task_id);
    } catch (error) {
        console.error('Error starting scan:', error);
        scanSection.innerHTML = `
            <p class="error">Error starting scan. Please try again.</p>
            <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
        `;
    }
}

// Poll for scan result
async function pollForScanResult(taskId) {
    const maxAttempts = 60;
    let attempts = 0;

    const poll = async () => {
        try {
            // Pass task_id to only get result for THIS scan, not stale cached results
            const response = await fetch(`/api/disc/scan-result?task_id=${encodeURIComponent(taskId)}`);
            if (response.ok) {
                scanResult = await response.json();
                displayScanResult(scanResult);
                return;
            }
            // 404 means task not complete yet - keep polling
        } catch (error) {
            console.log('Waiting for scan result...');
        }

        attempts++;
        if (attempts < maxAttempts) {
            setTimeout(poll, 2000);
        } else {
            document.getElementById('scan-section').innerHTML = `
                <p class="error">Scan timed out. Please try again.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
            `;
        }
    };

    poll();
}

// Show metadata links (TMDB/IMDB) for saved disc
function showMetadataLinks(title, tmdbId, imdbId) {
    const metadataLinksRow = document.getElementById('metadata-links-row');
    const metadataLinksDiv = document.getElementById('metadata-links');
    if (!metadataLinksDiv) return;

    metadataLinksDiv.innerHTML = '';

    if (tmdbId) {
        metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
        const tmdbLink = document.createElement('a');
        tmdbLink.href = `https://www.themoviedb.org/movie/${tmdbId}`;
        tmdbLink.target = '_blank';
        tmdbLink.textContent = title || 'TMDB';
        tmdbLink.style.marginRight = '0.5rem';
        metadataLinksDiv.appendChild(tmdbLink);
    }

    if (imdbId) {
        if (tmdbId) {
            metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
        } else {
            metadataLinksDiv.appendChild(document.createTextNode('IMDB: '));
        }
        const imdbLink = document.createElement('a');
        imdbLink.href = `https://www.imdb.com/title/${imdbId}`;
        imdbLink.target = '_blank';
        imdbLink.textContent = imdbId;
        metadataLinksDiv.appendChild(imdbLink);
    }

    if (tmdbId || imdbId) {
        metadataLinksRow.style.display = 'flex';
    }
}

// Display scan results
async function displayScanResult(result) {
    scanResult = result;

    // Check for saved metadata
    if (result.fingerprint) {
        try {
            const metaResponse = await fetch(`/api/disc/metadata/${result.fingerprint}`);
            if (metaResponse.ok) {
                const metadata = await metaResponse.json();
                if (metadata.title) {
                    document.getElementById('disc-title').value = metadata.title;
                }
                if (metadata.year) {
                    document.getElementById('disc-year').value = metadata.year;
                }
                if (metadata.tmdb_id) {
                    window.selectedTMDBId = metadata.tmdb_id;
                }
                if (metadata.imdb_id) {
                    window.selectedIMDBId = metadata.imdb_id;
                }
                // Show metadata links if we have IDs
                if (metadata.tmdb_id || metadata.imdb_id) {
                    showMetadataLinks(metadata.title, metadata.tmdb_id, metadata.imdb_id);
                }
            }
        } catch (error) {
            console.log('No saved metadata for disc');
        }
    }

    // Use textContent for text nodes to prevent XSS
    document.getElementById('disc-status-text').textContent = `${result.disc_name || 'Unknown'} (${result.disc_type || 'Unknown'})`;

    const scanSection = document.getElementById('scan-section');

    // Show duplicate removal info if available
    const dedupeInfo = result.duplicates_removed ? ` (${result.duplicates_removed} duplicate${result.duplicates_removed !== 1 ? 's' : ''} removed)` : '';

    scanSection.innerHTML = `
        <p class="scan-complete">Scan complete! Found ${result.tracks.length} track${result.tracks.length !== 1 ? 's' : ''}.${dedupeInfo}</p>
        <button class="btn btn-secondary" onclick="startScan()">Rescan</button>
    `;

    // Show disc info section
    const infoSection = document.getElementById('disc-info-section');
    infoSection.style.display = 'block';

    // Populate title only if not already set from saved metadata
    const titleInput = document.getElementById('disc-title');
    if (!titleInput.value) {
        titleInput.value = result.disc_name || '';
    }

    const tracksSection = document.getElementById('tracks-section');
    tracksSection.style.display = 'block';

    const tbody = document.getElementById('tracks-body');
    tbody.innerHTML = result.tracks.map((track, index) => `
        <tr class="track-row ${track.classification === 'main_feature' ? 'main-feature' : ''}"
            draggable="true"
            data-track-index="${index}"
            ondragstart="handleDragStart(event)"
            ondragover="handleDragOver(event)"
            ondrop="handleDrop(event)"
            ondragend="handleDragEnd(event)">
            <td class="col-drag"><span class="drag-handle">⋮⋮</span></td>
            <td class="col-select">
                <input type="checkbox" name="tracks" value="${track.number || index}"
                       onchange="updateSelectedCount()" data-classification="${escapeHtml(track.classification || 'unknown')}">
            </td>
            <td class="col-track">${track.number || index}</td>
            <td class="col-duration">${escapeHtml(track.duration || '-')}</td>
            <td class="col-size">${formatSize(track.size_bytes)}</td>
            <td class="col-resolution">${escapeHtml(track.resolution || '-')}</td>
            <td class="col-preset">
                <select class="preset-select" data-track-index="${index}">
                    <!-- Options populated by loadPresets() -->
                </select>
            </td>
            <td class="col-type">
                <select class="track-type-select type-${track.classification || 'unknown'}"
                        onchange="updateTrackClassification(this, ${index})"
                        data-track-index="${index}">
                    ${getTrackTypeOptions(track.classification || 'unknown')}
                </select>${getConfidenceIndicator(track.confidence)}
            </td>
            <td class="col-name">
                <input type="text" name="track_name_${track.number || index}"
                       class="track-name-input"
                       placeholder="${escapeHtml(getDefaultTrackName(track))}"
                       value="${escapeHtml(track.name || '')}">
            </td>
            <td class="col-audio">${track.audio_tracks || track.audio_streams?.length || 0}</td>
            <td class="col-subs">${track.subtitle_tracks || track.subtitle_streams?.length || 0}</td>
        </tr>
    `).join('');

    // After rendering tracks, populate preset dropdowns
    populateAllPresetDropdowns();

    updateSelectedCount();
}

function formatSize(bytes) {
    if (!bytes) return '-';
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(1) + ' GB';
}

function formatClassification(classification) {
    const labels = {
        'main_feature': 'Main Feature',
        'behind_the_scenes': 'Behind The Scenes',
        'deleted_scenes': 'Deleted Scene',
        'featurettes': 'Featurette',
        'interviews': 'Interview',
        'scenes': 'Scene',
        'shorts': 'Short',
        'trailers': 'Trailer',
        'other': 'Other',
        'unknown': 'Unknown',
    };
    return labels[classification] || classification || 'Unknown';
}

function getTrackTypeOptions(currentClassification) {
    const types = [
        'main_feature',
        'behind_the_scenes',
        'deleted_scenes',
        'featurettes',
        'interviews',
        'scenes',
        'shorts',
        'trailers',
        'other',
    ];

    return types.map(type => {
        const selected = type === currentClassification ? ' selected' : '';
        return `<option value="${type}"${selected}>${formatClassification(type)}</option>`;
    }).join('');
}

function updateTrackClassification(selectElement, trackIndex) {
    if (!scanResult || !scanResult.tracks || !scanResult.tracks[trackIndex]) {
        console.error('Invalid track index:', trackIndex);
        return;
    }

    const newClassification = selectElement.value;
    scanResult.tracks[trackIndex].classification = newClassification;

    // Remove confidence indicator when user manually changes classification
    const row = selectElement.closest('tr');
    if (!row) {
        console.error('Could not find parent row for track select');
        return;
    }

    const confidenceSpan = row.querySelector('.confidence');
    if (confidenceSpan) {
        confidenceSpan.remove();
    }

    // Update select element class to reflect new classification
    selectElement.className = `track-type-select type-${newClassification}`;

    // Update visual styling on the row
    row.classList.remove('main-feature');
    if (newClassification === 'main_feature') {
        row.classList.add('main-feature');
    }

    // Update checkbox data attribute
    const checkbox = row.querySelector('input[name="tracks"]');
    if (checkbox) {
        checkbox.dataset.classification = newClassification;
    }
}

function getConfidenceIndicator(confidence) {
    if (confidence === 'high') {
        return '<span class="confidence confidence-high">●●●</span>';
    } else if (confidence === 'medium') {
        return '<span class="confidence confidence-medium">●●○</span>';
    } else if (confidence === 'low') {
        return '<span class="confidence confidence-low">●○○</span>';
    }
    return '';
}

function getDefaultTrackName(track) {
    const classification = track.classification || 'unknown';

    if (classification === 'main_feature') {
        return 'Main Feature';
    } else if (classification === 'trailers') {
        return 'Trailer';
    } else if (classification === 'featurettes') {
        return 'Featurette';
    } else if (classification === 'behind_the_scenes') {
        return 'Behind The Scenes';
    } else if (classification === 'deleted_scenes') {
        return 'Deleted Scene';
    } else if (classification === 'interviews') {
        return 'Interview';
    } else if (classification === 'scenes') {
        return 'Scene';
    } else if (classification === 'shorts') {
        return 'Short';
    } else {
        return 'Extra';
    }
}

function selectAll() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = true);
    updateSelectedCount();
}

function selectNone() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = false);
    updateSelectedCount();
}

function selectMain() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => {
        cb.checked = cb.dataset.classification === 'main_feature';
    });
    updateSelectedCount();
}

function toggleAll(masterCheckbox) {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = masterCheckbox.checked);
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('input[name="tracks"]:checked').length;
    document.getElementById('selected-count').textContent = `${selected} track${selected !== 1 ? 's' : ''} selected`;
    document.getElementById('rip-button').disabled = selected === 0;

    // Update master checkbox
    const total = document.querySelectorAll('input[name="tracks"]').length;
    const masterCheckbox = document.getElementById('select-all-checkbox');
    masterCheckbox.checked = selected === total && total > 0;
    masterCheckbox.indeterminate = selected > 0 && selected < total;
}

async function submitRipTasks(event) {
    event.preventDefault();

    // Save disc metadata first (if we have TMDB/IMDB data)
    const fingerprint = scanResult?.fingerprint;
    const title = document.getElementById('disc-title').value.trim();
    const year = document.getElementById('disc-year').value.trim();

    if (fingerprint && title && year && (window.selectedTMDBId || window.selectedIMDBId)) {
        try {
            await fetch('/api/disc/metadata', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    fingerprint: fingerprint,
                    tmdb_id: window.selectedTMDBId || null,
                    imdb_id: window.selectedIMDBId || null,
                    title: title,
                    year: parseInt(year)
                })
            });
        } catch (error) {
            console.error('Failed to save metadata:', error);
            // Continue with processing even if metadata save fails
        }
    }

    const selectedTracks = Array.from(document.querySelectorAll('input[name="tracks"]:checked'))
        .map(cb => parseInt(cb.value));
    const outputDir = document.getElementById('output-dir').value;
    const discTitle = document.getElementById('disc-title').value;
    const discYear = document.getElementById('disc-year').value;

    if (selectedTracks.length === 0) {
        alert('Please select at least one track to rip.');
        return;
    }

    if (!discTitle || !discYear) {
        alert('Please enter a title and year for Plex-compatible naming.');
        return;
    }

    const ripButton = document.getElementById('rip-button');
    ripButton.disabled = true;
    ripButton.textContent = 'Creating tasks...';

    try {
        for (const trackNumber of selectedTracks) {
            const track = scanResult.tracks.find(t => (t.number || scanResult.tracks.indexOf(t)) === trackNumber);

            // Get track name from input field
            const trackNameInput = document.querySelector(`input[name="track_name_${trackNumber}"]`);
            const trackName = trackNameInput?.value || getDefaultTrackName(track);

            // Get classification (convert extra/trailer/menu to proper type)
            let trackType = track.classification || 'other';
            // Map generic 'extra' to 'other' for Plex naming
            if (trackType === 'extra') {
                trackType = 'other';
            }

            // Generate Plex-compatible filename
            // For now, assume language is 'en' - in future this could be configurable
            const outputFilename = generateTrackFilename(
                trackType,
                discTitle,
                parseInt(discYear),
                trackName,
                'en'
            );

            await fetch('/api/tasks/rip', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    track_number: trackNumber,
                    output_filename: outputFilename,
                    output_directory: outputDir,
                    disc_title: discTitle,
                    disc_year: parseInt(discYear),
                }),
            });
        }

        // Redirect to queue page
        window.location.href = '/queue';
    } catch (error) {
        console.error('Error creating rip tasks:', error);
        alert('Error creating rip tasks. Please try again.');
        ripButton.disabled = false;
        ripButton.textContent = 'Process Selected Tracks';
    }
}

// Search TMDB for movie matches
async function searchTMDB() {
    const query = document.getElementById('disc-title').value;
    const year = document.getElementById('disc-year').value;

    if (!query) {
        alert('Please enter a title to search');
        return;
    }

    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.style.display = 'block';
    resultsDiv.innerHTML = '<p class="text-muted" style="padding: 0.75rem;">Searching TMDB...</p>';

    try {
        let url = `/api/disc/search-tmdb?query=${encodeURIComponent(query)}`;
        if (year) {
            url += `&year=${encodeURIComponent(year)}`;
        }

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Search failed');
        }

        const data = await response.json();
        displayTMDBResults(data.results);
    } catch (error) {
        console.error('Error searching TMDB:', error);
        resultsDiv.innerHTML = '<p class="error" style="padding: 0.75rem;">Error searching TMDB. Check if API key is configured.</p>';
    }
}

// Display TMDB search results
function displayTMDBResults(results) {
    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.innerHTML = ''; // Clear previous

    if (!results || results.length === 0) {
        const p = document.createElement('p');
        p.className = 'text-muted';
        p.style.padding = '0.75rem';
        p.textContent = 'No results found';
        resultsDiv.appendChild(p);
        return;
    }

    results.forEach(movie => {
        const div = document.createElement('div');
        div.className = 'tmdb-result';
        div.onclick = () => selectTMDBResult(movie.id, movie.title, movie.year);

        const strong = document.createElement('strong');
        strong.textContent = movie.title;
        div.appendChild(strong);

        if (movie.year) {
            div.appendChild(document.createTextNode(` (${movie.year})`));
        }

        if (movie.overview) {
            div.appendChild(document.createElement('br'));
            const span = document.createElement('span');
            span.className = 'text-muted';
            span.style.fontSize = '0.85rem';
            const overview = movie.overview.length > 150
                ? movie.overview.substring(0, 150) + '...'
                : movie.overview;
            span.textContent = overview;
            div.appendChild(span);
        }

        resultsDiv.appendChild(div);
    });
}

// Select a TMDB result and fill in the form
async function selectTMDBResult(tmdbId, title, year) {
    document.getElementById('disc-title').value = title;
    if (year) {
        document.getElementById('disc-year').value = year;
    }

    // Hide results
    document.getElementById('tmdb-results').style.display = 'none';

    // Store TMDB ID for later use (e.g., fetching more metadata)
    window.selectedTMDBId = tmdbId;
    enableSaveButton();

    // Show metadata links row
    const metadataLinksRow = document.getElementById('metadata-links-row');
    const metadataLinksDiv = document.getElementById('metadata-links');
    metadataLinksRow.style.display = 'flex';

    // Create TMDB link immediately
    const tmdbUrl = `https://www.themoviedb.org/movie/${tmdbId}`;
    const tmdbLink = document.createElement('a');
    tmdbLink.href = tmdbUrl;
    tmdbLink.target = '_blank';
    tmdbLink.textContent = title;
    tmdbLink.style.marginRight = '0.5rem';

    // Show initial state with TMDB link and loading message for IMDB
    metadataLinksDiv.innerHTML = '';
    metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
    metadataLinksDiv.appendChild(tmdbLink);
    metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
    const loadingSpan = document.createElement('span');
    loadingSpan.className = 'text-muted';
    loadingSpan.textContent = 'Fetching...';
    metadataLinksDiv.appendChild(loadingSpan);

    // Fetch external IDs to get IMDB ID
    try {
        const response = await fetch(`/api/disc/tmdb-external-ids/${tmdbId}`);
        if (response.ok) {
            const externalIds = await response.json();
            if (externalIds.imdb_id) {
                window.selectedIMDBId = externalIds.imdb_id;
                console.log('IMDB ID:', externalIds.imdb_id);

                // Update with IMDB link
                const imdbUrl = `https://www.imdb.com/title/${externalIds.imdb_id}/`;
                const imdbLink = document.createElement('a');
                imdbLink.href = imdbUrl;
                imdbLink.target = '_blank';
                imdbLink.textContent = externalIds.imdb_id;

                // Rebuild the metadata links div with both links
                metadataLinksDiv.innerHTML = '';
                metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
                metadataLinksDiv.appendChild(tmdbLink);
                metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
                metadataLinksDiv.appendChild(imdbLink);
            } else {
                // No IMDB ID found
                loadingSpan.textContent = 'Not available';
            }
        } else {
            // API call failed
            loadingSpan.textContent = 'Not available';
        }
    } catch (error) {
        console.error('Error fetching external IDs:', error);
        // Update loading message to show error
        loadingSpan.textContent = 'Error fetching';
    }
}

// Set track names based on title, year, and classification
function setTrackNames() {
    const title = document.getElementById('disc-title').value;
    const year = document.getElementById('disc-year').value;

    // Validate inputs
    if (!title || !year) {
        alert('Please enter both a title and year before setting track names.');
        return;
    }

    if (!scanResult || !scanResult.tracks) {
        console.error('No tracks available');
        return;
    }

    // Strip year from title if present to prevent "(1999) (1999)"
    const titleWithoutYear = title.replace(/\s*\(\d{4}\)\s*$/, '');

    // Get IMDB ID if available (set when TMDB result is selected)
    const imdbId = window.selectedIMDBId || null;
    const imdbSuffix = imdbId ? ` {imdb-${imdbId}}` : '';

    // First pass: collect main feature durations
    const mainFeatureDurations = new Set();
    scanResult.tracks.forEach((track) => {
        const classification = track.classification || 'other';
        if (classification === 'main_feature' && track.duration) {
            mainFeatureDurations.add(track.duration);
        }
    });

    // Count each type for numbering
    const typeCounts = {};
    const failedTracks = [];
    let alternateVersionCount = 1; // Start at 1 for the first alternate (main feature is implicit version 1)

    // Process each track
    scanResult.tracks.forEach((track, index) => {
        const classification = track.classification || 'other';
        const trackNumber = track.number || index;
        const nameInput = document.querySelector(`input[name="track_name_${trackNumber}"]`);

        if (!nameInput) {
            console.warn(`No input found for track ${trackNumber}`);
            failedTracks.push(trackNumber);
            return;
        }

        let trackName;

        // Main feature: use title, add part number if multiple
        if (classification === 'main_feature') {
            // Initialize counter for main features if not present
            if (!typeCounts[classification]) {
                typeCounts[classification] = 0;
            }
            typeCounts[classification]++;

            const count = typeCounts[classification];

            // Add " - Part N" only if there are multiple main features
            trackName = `${titleWithoutYear} (${year})${imdbSuffix}`;
            if (count > 1) {
                trackName += ` - Part ${count}`;
            }
        } else if (track.duration && mainFeatureDurations.has(track.duration)) {
            // Alternate version: same duration as a main feature
            alternateVersionCount++;
            trackName = `${titleWithoutYear} (${year})${imdbSuffix} - Version ${alternateVersionCount}`;
        } else {
            // Extras: use getDefaultTrackName() as base, then add count
            const baseName = getDefaultTrackName(track);

            // Initialize counter for this type if not present
            if (!typeCounts[classification]) {
                typeCounts[classification] = 0;
            }
            typeCounts[classification]++;

            const count = typeCounts[classification];
            trackName = `${baseName} ${count}`;
        }

        // Set the track name input value
        nameInput.value = trackName;
    });

    // Show alert if any tracks failed
    if (failedTracks.length > 0) {
        alert(`Warning: Could not set names for ${failedTracks.length} track(s): ${failedTracks.join(', ')}`);
    }
}

// Load config and set default output directory
async function loadConfig() {
    try {
        const response = await fetch('/config.json');
        if (response.ok) {
            const config = await response.json();
            const outputDirInput = document.getElementById('output-dir');
            if (config.ripped_directory) {
                outputDirInput.value = config.ripped_directory;
                outputDirInput.placeholder = config.ripped_directory;
            } else {
                // Fallback to default if not in config
                outputDirInput.value = '/media/ripped';
                outputDirInput.placeholder = '/media/ripped';
            }
        }
    } catch (error) {
        console.error('Error loading config:', error);
        // Fallback to default on error
        const outputDirInput = document.getElementById('output-dir');
        outputDirInput.value = '/media/ripped';
        outputDirInput.placeholder = '/media/ripped';
    }
}

// Save disc info to database
async function saveDiscInfo() {
    const fingerprint = scanResult?.fingerprint;
    if (!fingerprint) {
        alert('No disc fingerprint available');
        return;
    }

    const title = document.getElementById('disc-title').value.trim();
    const year = document.getElementById('disc-year').value.trim();

    if (!title || !year) {
        alert('Please enter title and year');
        return;
    }

    try {
        const response = await fetch('/api/disc/metadata', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                fingerprint: fingerprint,
                tmdb_id: window.selectedTMDBId || null,
                imdb_id: window.selectedIMDBId || null,
                title: title,
                year: parseInt(year)
            })
        });

        if (response.ok) {
            // Visual feedback
            const btn = document.getElementById('save-disc-info-btn');
            btn.textContent = 'Saved!';
            btn.disabled = true;
            setTimeout(() => {
                btn.textContent = 'Save Disc Info';
                btn.disabled = false;
            }, 2000);
        } else {
            const error = await response.json();
            alert('Failed to save: ' + (error.detail || 'Unknown error'));
        }
    } catch (error) {
        alert('Failed to save: ' + error.message);
    }
}

function enableSaveButton() {
    const btn = document.getElementById('save-disc-info-btn');
    if (btn) btn.disabled = false;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
    // Load presets first, then populate dropdowns if scan is already displayed
    await loadPresets();
    loadConfig();
    checkDiscStatus();
    // In case scan result was cached and displayed before presets loaded
    populateAllPresetDropdowns();
});

// Listen for WebSocket disc events
document.addEventListener('amphigory:disc_event', (e) => {
    checkDiscStatus();
});
</script>
{% endblock %}
