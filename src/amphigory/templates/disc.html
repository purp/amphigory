{% extends "base.html" %}

{% block title %}Disc Review - Amphigory{% endblock %}

{% block content %}
<div class="disc-review">
    <header class="page-header">
        <h1>Disc Review</h1>
        <p class="subtitle" id="disc-status-text">Loading...</p>
    </header>

    <section class="scan-section card" id="scan-section">
        <div id="scan-status">
            <p class="text-muted">Checking for disc...</p>
        </div>
    </section>

    <section class="disc-info card" id="disc-info-section" style="display: none;">
        <h3>Disc Information</h3>
        <div class="form-row">
            <label for="disc-title">Title:</label>
            <div style="display: flex; gap: 0.5rem; flex: 1;">
                <input type="text" id="disc-title" name="disc_title"
                       class="setting-input" placeholder="Enter disc title">
                <button type="button" class="btn btn-small" onclick="searchTMDB()">Search TMDB</button>
            </div>
        </div>
        <div id="tmdb-results" class="tmdb-results" style="display: none;">
            <!-- TMDB results populated via JavaScript -->
        </div>
        <div class="form-row">
            <label for="disc-year">Year:</label>
            <input type="number" id="disc-year" name="disc_year"
                   class="setting-input setting-input-small" placeholder="YYYY"
                   min="1900" max="2100">
        </div>
    </section>

    <section class="tracks-section card" id="tracks-section" style="display: none;">
        <div class="tracks-header">
            <h2>Tracks</h2>
            <div class="track-actions">
                <button type="button" class="btn btn-small" onclick="selectMain()">Select Main Feature</button>
            </div>
        </div>

        <form id="rip-form" onsubmit="submitRipTasks(event)">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-drag"></th>
                        <th class="col-select"><input type="checkbox" id="select-all-checkbox" onchange="toggleAll(this)"></th>
                        <th class="col-track">#</th>
                        <th class="col-duration">Duration</th>
                        <th class="col-size">Size</th>
                        <th class="col-resolution">Resolution</th>
                        <th class="col-type">Type</th>
                        <th class="col-name">Track Name</th>
                        <th class="col-audio">Audio</th>
                        <th class="col-subs">Subs</th>
                    </tr>
                </thead>
                <tbody id="tracks-body">
                    <!-- Tracks populated via JavaScript -->
                </tbody>
            </table>

            <div class="rip-options">
                <div class="option-row">
                    <label for="output-dir">Output Directory:</label>
                    <input type="text" id="output-dir" name="output_dir" value="/media/ripped" class="setting-input">
                </div>
            </div>

            <div class="form-actions">
                <button type="submit" class="btn btn-primary" id="rip-button" disabled>
                    Process Selected Tracks
                </button>
                <span class="selected-count" id="selected-count">0 tracks selected</span>
            </div>
        </form>
    </section>
</div>

<script>
let scanResult = null;
let draggedRow = null;

// HTML escaping to prevent XSS
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Plex naming helper functions (mirror Python naming.py logic)
const PLEX_SUFFIXES = {
    'behind_the_scenes': '-behindthescenes',
    'deleted_scenes': '-deleted',
    'featurettes': '-featurette',
    'interviews': '-interview',
    'scenes': '-scene',
    'shorts': '-short',
    'trailers': '-trailer',
    'other': '-other',
};

function sanitizeFilename(name) {
    // Check for null/undefined
    if (!name) return '';

    // Remove invalid filename characters
    const invalidChars = '<>:"/\\|?*';
    let result = name;
    for (const char of invalidChars) {
        result = result.split(char).join('');
    }
    return result;
}

function generateTrackFilename(trackType, movieTitle, year, trackName, language) {
    // Check for null/undefined inputs
    if (!movieTitle || !year || !trackName) {
        console.error('Missing required parameters for generateTrackFilename');
        return 'unknown.mkv';
    }

    // Sanitize inputs
    const sanitizedTitle = sanitizeFilename(movieTitle);
    const sanitizedTrackName = sanitizeFilename(trackName);

    // Main feature naming
    if (trackType === 'main_feature') {
        // Check if this is an alternate language version (not en/en-us/english)
        if (language && !['en', 'en-us', 'english'].includes(language.toLowerCase())) {
            return `${sanitizedTitle} (${year}) - ${language}.mkv`;
        } else {
            return `${sanitizedTitle} (${year}).mkv`;
        }
    }

    // Extras naming: "Track Name-suffix.mkv"
    const suffix = PLEX_SUFFIXES[trackType] || '-other';
    return `${sanitizedTrackName}${suffix}.mkv`;
}

// Drag and drop handlers
function handleDragStart(e) {
    // Clear any stale drag state (e.g., from cancelled drags)
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
    }
    draggedRow = e.target.closest('tr');
    if (draggedRow && draggedRow.classList.contains('track-row')) {
        draggedRow.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const targetRow = e.target.closest('tr');
    if (targetRow && targetRow !== draggedRow && targetRow.classList.contains('track-row')) {
        const tbody = targetRow.parentNode;
        const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
        const draggedIdx = rows.indexOf(draggedRow);
        const targetIdx = rows.indexOf(targetRow);

        if (draggedIdx >= 0 && targetIdx >= 0) {
            if (draggedIdx < targetIdx) {
                targetRow.after(draggedRow);
            } else {
                targetRow.before(draggedRow);
            }
        }
    }
}

function handleDrop(e) {
    e.preventDefault();
}

function handleDragEnd(e) {
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
        draggedRow = null;
        updateTrackOrder();
    }
}

function updateTrackOrder() {
    // Update scanResult.tracks to match new DOM order
    const tbody = document.getElementById('tracks-body');
    if (!tbody || !scanResult || !scanResult.tracks) return;

    const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
    const newOrder = [];

    for (const row of rows) {
        const input = row.querySelector('input[name="tracks"]');
        if (!input) continue;

        const trackNum = parseInt(input.value);
        if (isNaN(trackNum)) continue;

        const track = scanResult.tracks.find(t => t.number === trackNum);
        if (track) newOrder.push(track);
    }

    if (newOrder.length > 0) {
        scanResult.tracks = newOrder;
    }
}

// Check disc status and show scan button
async function checkDiscStatus() {
    try {
        const response = await fetch('/api/disc/status');
        const data = await response.json();

        const statusText = document.getElementById('disc-status-text');
        const scanSection = document.getElementById('scan-section');

        if (data.has_disc) {
            // Check if we have cached scan results in memory
            try {
                const scanResponse = await fetch('/api/disc/current-scan');
                if (scanResponse.ok) {
                    scanResult = await scanResponse.json();
                    displayScanResult(scanResult);
                    return;
                }
            } catch (err) {
                // No cached scan in memory - check database by fingerprint
            }

            // Check if disc is known in database by fingerprint
            try {
                const lookupResponse = await fetch('/api/disc/lookup-fingerprint');
                if (lookupResponse.ok) {
                    const discInfo = await lookupResponse.json();
                    if (discInfo.scan_data) {
                        // Show option to use cached scan or rescan
                        statusText.textContent = `Known disc: ${discInfo.title}`;
                        const scannedDate = discInfo.scanned_at ? new Date(discInfo.scanned_at).toLocaleDateString() : 'previously';
                        scanSection.innerHTML = `
                            <p class="text-muted">Previously scanned on ${scannedDate}</p>
                            <button class="btn btn-primary" onclick="loadCachedScan()">
                                Load Previous Scan
                            </button>
                            <button class="btn btn-secondary" onclick="startScan()" style="margin-left: 0.5rem;">
                                Rescan Disc
                            </button>
                        `;
                        // Store disc info for later use
                        window.knownDiscInfo = discInfo;
                        return;
                    }
                }
            } catch (err) {
                // Disc not in database - continue to show scan button
            }

            // No cached scan - show scan button
            statusText.textContent = `Disc: ${data.volume_name || 'Unknown'} (${data.device_path})`;
            scanSection.innerHTML = `
                <button class="btn btn-primary" onclick="startScan()">
                    Scan Disc
                </button>
                <span class="text-muted" style="margin-left: 1rem;">Click to analyze disc contents</span>
            `;
        } else {
            statusText.textContent = 'No disc detected';
            scanSection.innerHTML = `
                <p class="text-muted">Insert a disc and click refresh to scan.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Refresh</button>
            `;
        }
    } catch (error) {
        console.error('Error checking disc status:', error);
        document.getElementById('disc-status-text').textContent = 'Error checking disc status';
    }
}

// Load cached scan data from database
function loadCachedScan() {
    if (!window.knownDiscInfo || !window.knownDiscInfo.scan_data) {
        console.error('No cached scan data available');
        return;
    }

    scanResult = window.knownDiscInfo.scan_data;
    displayScanResult(scanResult);
}

// Start a scan
async function startScan() {
    const scanSection = document.getElementById('scan-section');
    scanSection.innerHTML = `
        <div class="scanning">
            <div class="spinner"></div>
            <p>Scanning disc...</p>
        </div>
    `;

    try {
        const response = await fetch('/api/disc/scan', { method: 'POST' });
        const data = await response.json();

        // Poll for results
        pollForScanResult(data.task_id);
    } catch (error) {
        console.error('Error starting scan:', error);
        scanSection.innerHTML = `
            <p class="error">Error starting scan. Please try again.</p>
            <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
        `;
    }
}

// Poll for scan result
async function pollForScanResult(taskId) {
    const maxAttempts = 60;
    let attempts = 0;

    const poll = async () => {
        try {
            // Pass task_id to only get result for THIS scan, not stale cached results
            const response = await fetch(`/api/disc/scan-result?task_id=${encodeURIComponent(taskId)}`);
            if (response.ok) {
                scanResult = await response.json();
                displayScanResult(scanResult);
                return;
            }
            // 404 means task not complete yet - keep polling
        } catch (error) {
            console.log('Waiting for scan result...');
        }

        attempts++;
        if (attempts < maxAttempts) {
            setTimeout(poll, 2000);
        } else {
            document.getElementById('scan-section').innerHTML = `
                <p class="error">Scan timed out. Please try again.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
            `;
        }
    };

    poll();
}

// Display scan results
function displayScanResult(result) {
    // Use textContent for text nodes to prevent XSS
    document.getElementById('disc-status-text').textContent = `${result.disc_name || 'Unknown'} (${result.disc_type || 'Unknown'})`;

    const scanSection = document.getElementById('scan-section');

    // Show duplicate removal info if available
    const dedupeInfo = result.duplicates_removed ? ` (${result.duplicates_removed} duplicate${result.duplicates_removed !== 1 ? 's' : ''} removed)` : '';

    scanSection.innerHTML = `
        <p class="scan-complete">Scan complete! Found ${result.tracks.length} track${result.tracks.length !== 1 ? 's' : ''}.${dedupeInfo}</p>
        <button class="btn btn-secondary" onclick="startScan()">Rescan</button>
    `;

    // Show disc info section
    const infoSection = document.getElementById('disc-info-section');
    infoSection.style.display = 'block';

    // Populate title (editable) - safe because it's setting a value property, not innerHTML
    document.getElementById('disc-title').value = result.disc_name || '';

    const tracksSection = document.getElementById('tracks-section');
    tracksSection.style.display = 'block';

    const tbody = document.getElementById('tracks-body');
    tbody.innerHTML = result.tracks.map((track, index) => `
        <tr class="track-row ${track.classification === 'main_feature' ? 'main-feature' : ''}"
            draggable="true"
            data-track-index="${index}"
            ondragstart="handleDragStart(event)"
            ondragover="handleDragOver(event)"
            ondrop="handleDrop(event)"
            ondragend="handleDragEnd(event)">
            <td class="col-drag"><span class="drag-handle">⋮⋮</span></td>
            <td class="col-select">
                <input type="checkbox" name="tracks" value="${track.number || index}"
                       onchange="updateSelectedCount()" data-classification="${escapeHtml(track.classification || 'unknown')}">
            </td>
            <td class="col-track">${track.number || index}</td>
            <td class="col-duration">${escapeHtml(track.duration || '-')}</td>
            <td class="col-size">${formatSize(track.size_bytes)}</td>
            <td class="col-resolution">${escapeHtml(track.resolution || '-')}</td>
            <td class="col-type">
                <span class="track-type type-${track.classification || 'unknown'}">
                    ${formatClassification(track.classification)}
                </span>${getConfidenceIndicator(track.confidence)}
            </td>
            <td class="col-name">
                <input type="text" name="track_name_${track.number || index}"
                       class="track-name-input"
                       placeholder="${escapeHtml(getDefaultTrackName(track))}"
                       value="${escapeHtml(track.name || '')}">
            </td>
            <td class="col-audio">${track.audio_tracks || track.audio_streams?.length || 0}</td>
            <td class="col-subs">${track.subtitle_tracks || track.subtitle_streams?.length || 0}</td>
        </tr>
    `).join('');

    updateSelectedCount();
}

function formatSize(bytes) {
    if (!bytes) return '-';
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(1) + ' GB';
}

function formatClassification(classification) {
    const labels = {
        'main_feature': 'Main Feature',
        'trailers': 'Trailer',
        'featurettes': 'Featurette',
        'deleted_scenes': 'Deleted Scene',
        'other': 'Other',
        'unknown': 'Unknown',
    };
    return labels[classification] || classification || 'Unknown';
}

function getConfidenceIndicator(confidence) {
    if (confidence === 'high') {
        return '<span class="confidence confidence-high">●●●</span>';
    } else if (confidence === 'medium') {
        return '<span class="confidence confidence-medium">●●○</span>';
    } else if (confidence === 'low') {
        return '<span class="confidence confidence-low">●○○</span>';
    }
    return '';
}

function getDefaultTrackName(track) {
    const classification = track.classification || 'unknown';

    if (classification === 'main_feature') {
        return 'Main Feature';
    } else if (classification === 'trailers') {
        return 'Trailer';
    } else if (classification === 'featurettes') {
        return 'Featurette';
    } else if (classification === 'behind_the_scenes') {
        return 'Behind The Scenes';
    } else if (classification === 'deleted_scenes') {
        return 'Deleted Scene';
    } else if (classification === 'interviews') {
        return 'Interview';
    } else if (classification === 'scenes') {
        return 'Scene';
    } else if (classification === 'shorts') {
        return 'Short';
    } else {
        return 'Extra';
    }
}

function selectAll() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = true);
    updateSelectedCount();
}

function selectNone() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = false);
    updateSelectedCount();
}

function selectMain() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => {
        cb.checked = cb.dataset.classification === 'main_feature';
    });
    updateSelectedCount();
}

function toggleAll(masterCheckbox) {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = masterCheckbox.checked);
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('input[name="tracks"]:checked').length;
    document.getElementById('selected-count').textContent = `${selected} track${selected !== 1 ? 's' : ''} selected`;
    document.getElementById('rip-button').disabled = selected === 0;

    // Update master checkbox
    const total = document.querySelectorAll('input[name="tracks"]').length;
    const masterCheckbox = document.getElementById('select-all-checkbox');
    masterCheckbox.checked = selected === total && total > 0;
    masterCheckbox.indeterminate = selected > 0 && selected < total;
}

async function submitRipTasks(event) {
    event.preventDefault();

    const selectedTracks = Array.from(document.querySelectorAll('input[name="tracks"]:checked'))
        .map(cb => parseInt(cb.value));
    const outputDir = document.getElementById('output-dir').value;
    const discTitle = document.getElementById('disc-title').value;
    const discYear = document.getElementById('disc-year').value;

    if (selectedTracks.length === 0) {
        alert('Please select at least one track to rip.');
        return;
    }

    if (!discTitle || !discYear) {
        alert('Please enter a title and year for Plex-compatible naming.');
        return;
    }

    const ripButton = document.getElementById('rip-button');
    ripButton.disabled = true;
    ripButton.textContent = 'Creating tasks...';

    try {
        for (const trackNumber of selectedTracks) {
            const track = scanResult.tracks.find(t => (t.number || scanResult.tracks.indexOf(t)) === trackNumber);

            // Get track name from input field
            const trackNameInput = document.querySelector(`input[name="track_name_${trackNumber}"]`);
            const trackName = trackNameInput?.value || getDefaultTrackName(track);

            // Get classification (convert extra/trailer/menu to proper type)
            let trackType = track.classification || 'other';
            // Map generic 'extra' to 'other' for Plex naming
            if (trackType === 'extra') {
                trackType = 'other';
            }

            // Generate Plex-compatible filename
            // For now, assume language is 'en' - in future this could be configurable
            const outputFilename = generateTrackFilename(
                trackType,
                discTitle,
                parseInt(discYear),
                trackName,
                'en'
            );

            await fetch('/api/tasks/rip', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    track_number: trackNumber,
                    output_filename: outputFilename,
                    output_directory: outputDir,
                    disc_title: discTitle,
                    disc_year: parseInt(discYear),
                }),
            });
        }

        // Redirect to queue page
        window.location.href = '/queue';
    } catch (error) {
        console.error('Error creating rip tasks:', error);
        alert('Error creating rip tasks. Please try again.');
        ripButton.disabled = false;
        ripButton.textContent = 'Process Selected Tracks';
    }
}

// Search TMDB for movie matches
async function searchTMDB() {
    const query = document.getElementById('disc-title').value;
    const year = document.getElementById('disc-year').value;

    if (!query) {
        alert('Please enter a title to search');
        return;
    }

    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.style.display = 'block';
    resultsDiv.innerHTML = '<p class="text-muted" style="padding: 0.75rem;">Searching TMDB...</p>';

    try {
        let url = `/api/disc/search-tmdb?query=${encodeURIComponent(query)}`;
        if (year) {
            url += `&year=${encodeURIComponent(year)}`;
        }

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Search failed');
        }

        const data = await response.json();
        displayTMDBResults(data.results);
    } catch (error) {
        console.error('Error searching TMDB:', error);
        resultsDiv.innerHTML = '<p class="error" style="padding: 0.75rem;">Error searching TMDB. Check if API key is configured.</p>';
    }
}

// Display TMDB search results
function displayTMDBResults(results) {
    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.innerHTML = ''; // Clear previous

    if (!results || results.length === 0) {
        const p = document.createElement('p');
        p.className = 'text-muted';
        p.style.padding = '0.75rem';
        p.textContent = 'No results found';
        resultsDiv.appendChild(p);
        return;
    }

    results.forEach(movie => {
        const div = document.createElement('div');
        div.className = 'tmdb-result';
        div.onclick = () => selectTMDBResult(movie.id, movie.title, movie.year);

        const strong = document.createElement('strong');
        strong.textContent = movie.title;
        div.appendChild(strong);

        if (movie.year) {
            div.appendChild(document.createTextNode(` (${movie.year})`));
        }

        if (movie.overview) {
            div.appendChild(document.createElement('br'));
            const span = document.createElement('span');
            span.className = 'text-muted';
            span.style.fontSize = '0.85rem';
            const overview = movie.overview.length > 150
                ? movie.overview.substring(0, 150) + '...'
                : movie.overview;
            span.textContent = overview;
            div.appendChild(span);
        }

        resultsDiv.appendChild(div);
    });
}

// Select a TMDB result and fill in the form
function selectTMDBResult(tmdbId, title, year) {
    document.getElementById('disc-title').value = title;
    if (year) {
        document.getElementById('disc-year').value = year;
    }

    // Hide results
    document.getElementById('tmdb-results').style.display = 'none';

    // Store TMDB ID for later use (e.g., fetching more metadata)
    window.selectedTMDBId = tmdbId;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', checkDiscStatus);

// Listen for WebSocket disc events
document.addEventListener('amphigory:disc_event', (e) => {
    checkDiscStatus();
});
</script>
{% endblock %}
