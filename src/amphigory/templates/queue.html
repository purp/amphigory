{% extends "base.html" %}

{% block title %}Queue - Amphigory{% endblock %}

{% block content %}
<div class="queue-page">
    <div class="queue-paused-banner" id="paused-banner" style="display: none;">
        PAUSED - Queue processing is paused
    </div>
    <header class="page-header">
        <div class="page-header-content">
            <h1>Task Queue</h1>
            <button class="btn btn-small btn-secondary" id="pause-btn" onclick="togglePause()">
                Pause Queue
            </button>
        </div>
    </header>

    <section class="current-task card" id="current-task-section">
        <h2>Current Task</h2>
        <div id="current-task">
            <p class="text-muted">No task currently running</p>
        </div>
    </section>

    <section class="queued-tasks card">
        <h2>Queued Tasks</h2>
        <div id="queued-tasks">
            <p class="text-muted">No tasks in queue</p>
        </div>
    </section>

    <section class="completed-tasks card">
        <div class="section-header">
            <h2>Recently Completed</h2>
            <button class="btn btn-small btn-secondary" onclick="toggleCompleted()">
                Show/Hide
            </button>
        </div>
        <div id="completed-tasks" class="collapsed">
            <p class="text-muted">No completed tasks</p>
        </div>
    </section>

    <section class="failed-tasks card" id="failed-tasks-section" style="display: none;">
        <div class="section-header">
            <h2>Failed Tasks</h2>
        </div>
        <div id="failed-tasks">
            <p class="text-muted">No failed tasks</p>
        </div>
    </section>
</div>

<script>
let tasks = { queued: [], in_progress: [], completed: [] };
let elapsedInterval = null;
let failedTasks = [];
let expandedQueuedTasks = new Set(); // Track which queued tasks are expanded
let isPaused = false; // Track queue pause state

async function loadFailedTasks() {
    try {
        const response = await fetch('/api/tasks/failed');
        const data = await response.json();
        failedTasks = data.tasks;
        renderFailedTasks();
    } catch (error) {
        console.error('Error loading failed tasks:', error);
    }
}

function renderFailedTasks() {
    const section = document.getElementById('failed-tasks-section');
    const container = document.getElementById('failed-tasks');

    if (failedTasks.length === 0) {
        section.style.display = 'none';
        return;
    }

    section.style.display = 'block';
    container.innerHTML = failedTasks.map(task => {
        const errorMsg = task.error?.message || task.error?.detail || 'Unknown error';
        const errorDetail = task.error?.detail || '';

        let detailsHtml = `
            <div class="detail-row"><span class="detail-label">Task ID:</span> ${task.id}</div>
            <div class="detail-row"><span class="detail-label">Type:</span> ${task.type || 'task'}</div>
            <div class="detail-row"><span class="detail-label">Started:</span> ${formatDateTime(task.started_at)}</div>
            <div class="detail-row"><span class="detail-label">Failed:</span> ${formatDateTime(task.completed_at)}</div>
        `;

        if (task.error?.code) {
            detailsHtml += `<div class="detail-row"><span class="detail-label">Error Code:</span> ${task.error.code}</div>`;
        }
        detailsHtml += `<div class="detail-row detail-error"><span class="detail-label">Error:</span> ${errorMsg}</div>`;
        if (errorDetail && errorDetail !== errorMsg) {
            detailsHtml += `<div class="detail-row detail-error"><span class="detail-label">Detail:</span> ${errorDetail}</div>`;
        }

        return `
            <div class="task-item task-failed" onclick="toggleFailedTaskDetails(event, '${task.id}')">
                <div class="task-header">
                    <span class="task-status status-failed">&#10007; failed</span>
                    <span class="task-type">${task.type || 'task'}</span>
                    <span class="task-id" title="${task.id}">${formatTaskId(task.id)}</span>
                    <span class="task-expand" id="expand-failed-${task.id}">&#9660;</span>
                </div>
                <div class="task-error-summary">
                    ${errorMsg}
                </div>
                <div class="task-details" id="details-failed-${task.id}" style="display: none;">
                    ${detailsHtml}
                </div>
                <div class="task-actions">
                    <button class="btn btn-small btn-secondary" onclick="dismissFailedTask(event, '${task.id}')">
                        Dismiss
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

async function dismissFailedTask(event, taskId) {
    event.stopPropagation();
    if (!confirm('Dismiss this failed task?')) return;

    try {
        const response = await fetch(`/api/tasks/failed/${encodeURIComponent(taskId)}`, {
            method: 'DELETE'
        });
        if (response.ok) {
            loadFailedTasks();
        } else {
            const error = await response.json();
            alert('Failed to dismiss task: ' + (error.detail || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error dismissing task:', error);
        alert('Error dismissing task');
    }
}

function toggleFailedTaskDetails(event, taskId) {
    // Don't toggle if clicking on the dismiss button
    if (event.target.closest('.task-actions')) return;

    const details = document.getElementById(`details-failed-${taskId}`);
    const expand = document.getElementById(`expand-failed-${taskId}`);

    if (details.style.display === 'none') {
        details.style.display = 'block';
        expand.innerHTML = '&#9650;';
    } else {
        details.style.display = 'none';
        expand.innerHTML = '&#9660;';
    }
}

function formatTime(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
}

function formatDuration(seconds) {
    if (!seconds) return '--';

    if (seconds < 60) return `${seconds}s`;

    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;

    if (minutes < 60) return `${minutes}m ${secs}s`;

    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours}h ${mins}m ${secs}s`;
}

function formatDateTime(dateStr) {
    if (!dateStr) return '--';
    const date = new Date(dateStr);
    return date.toLocaleString([], {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
    });
}

function formatTaskId(taskId) {
    // Format task ID to show last 11 chars before hyphen + hyphen + type
    // e.g., "20251227T204148.623581-rip" -> "4148.623581-rip"
    // Pattern should match: \d{4}\.\d{6}-[^\.]+
    const id = taskId.replace(/\.json$/, '');
    const hyphenIndex = id.lastIndexOf('-');
    if (hyphenIndex < 11) return id; // Fallback for unexpected format
    const prefix = id.substring(hyphenIndex - 11, hyphenIndex);
    const suffix = id.substring(hyphenIndex);
    return prefix + suffix;
}

function formatElapsed(startDateStr) {
    const start = new Date(startDateStr);
    const now = new Date();
    const seconds = Math.floor((now - start) / 1000);

    if (seconds < 60) return `${seconds}s`;

    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;

    if (minutes < 60) return `${minutes}m ${secs}s`;

    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours}h ${mins}m ${secs}s`;
}

async function loadTasks() {
    try {
        const response = await fetch('/api/tasks');
        const data = await response.json();

        // Update pause state from API response
        if (data.paused !== undefined) {
            isPaused = data.paused;
            updatePauseUI();
        }

        // Group by status
        tasks.queued = data.tasks.filter(t => t.status === 'queued');
        tasks.in_progress = data.tasks.filter(t => t.status === 'in_progress');
        tasks.completed = data.tasks.filter(t => t.status === 'success' || t.status === 'failed');

        renderCurrentTask();
        renderQueuedTasks();
        renderCompletedTasks();
    } catch (error) {
        console.error('Error loading tasks:', error);
    }
}

function renderCurrentTask() {
    const container = document.getElementById('current-task');

    // Clear any existing interval
    if (elapsedInterval) {
        clearInterval(elapsedInterval);
        elapsedInterval = null;
    }

    if (tasks.in_progress.length === 0) {
        container.innerHTML = '<p class="text-muted">No task currently running</p>';
        return;
    }

    const task = tasks.in_progress[0];
    const startedAt = task.started_at;
    const hasStartTime = startedAt && startedAt !== '';

    container.innerHTML = `
        <div class="task-item task-running">
            <div class="task-header">
                <span class="task-type">${task.type}</span>
                <span class="task-id" title="${task.id}">${formatTaskId(task.id)}</span>
            </div>
            ${hasStartTime ? `
            <div class="task-timing">
                Started: ${formatTime(startedAt)} Â· Elapsed: <span id="elapsed-time">${formatElapsed(startedAt)}</span>
            </div>
            ` : ''}
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="progress-${task.id}" style="width: ${task.progress_percent || 0}%"></div>
                </div>
                <span class="progress-text" id="progress-text-${task.id}">${task.progress_percent ? task.progress_percent + '%' : 'Processing...'}</span>
            </div>
        </div>
    `;

    // Update elapsed time every second
    if (hasStartTime) {
        elapsedInterval = setInterval(() => {
            const elapsedSpan = document.getElementById('elapsed-time');
            if (elapsedSpan) {
                elapsedSpan.textContent = formatElapsed(startedAt);
            }
        }, 1000);
    }
}

function renderQueuedTasks() {
    const container = document.getElementById('queued-tasks');

    if (tasks.queued.length === 0) {
        container.innerHTML = '<p class="text-muted">No tasks in queue</p>';
        return;
    }

    container.innerHTML = tasks.queued.map((task, index) => {
        let detailsHtml = `
            <div class="detail-row"><span class="detail-label">Task ID:</span> ${task.id}</div>
            <div class="detail-row"><span class="detail-label">Created:</span> ${formatDateTime(task.created_at)}</div>
        `;

        if (task.type === 'rip') {
            if (task.output_filename) {
                detailsHtml += `<div class="detail-row"><span class="detail-label">Output:</span> ${task.output_filename}</div>`;
            }
            if (task.track_number !== undefined) {
                detailsHtml += `<div class="detail-row"><span class="detail-label">Track:</span> ${task.track_number}</div>`;
            }
        }

        // Check if this task was expanded before
        const wasExpanded = expandedQueuedTasks.has(task.id);

        return `
            <div class="task-item task-queued" onclick="toggleQueuedTaskDetails('${task.id}')">
                <div class="task-header">
                    <span class="task-position">#${index + 1}</span>
                    <span class="task-type">${task.type}</span>
                    <span class="task-id" title="${task.id}">${formatTaskId(task.id)}</span>
                    <span class="task-expand" id="expand-queued-${task.id}">${wasExpanded ? '&#9650;' : '&#9660;'}</span>
                </div>
                <div class="task-details" id="details-queued-${task.id}" style="display: ${wasExpanded ? 'block' : 'none'};">
                    ${detailsHtml}
                </div>
            </div>
        `;
    }).join('');
}

function renderCompletedTasks() {
    const container = document.getElementById('completed-tasks');

    if (tasks.completed.length === 0) {
        container.innerHTML = '<p class="text-muted">No completed tasks</p>';
        return;
    }

    // Sort by completed_at descending (most recent first), then limit to 10
    const recentTasks = tasks.completed
        .sort((a, b) => {
            const aTime = a.completed_at ? new Date(a.completed_at).getTime() : 0;
            const bTime = b.completed_at ? new Date(b.completed_at).getTime() : 0;
            return bTime - aTime;
        })
        .slice(0, 10);

    container.innerHTML = recentTasks.map(task => {
        const statusIcon = task.status === 'success' ? '&#10003;' : '&#10007;';
        const outputDir = task.result?.destination?.directory || '';
        const outputFile = task.result?.destination?.filename || '';
        const errorMsg = task.error?.detail || task.error?.message || task.error || '';

        let detailsHtml = `
            <div class="detail-row"><span class="detail-label">Task ID:</span> ${task.id}</div>
            <div class="detail-row"><span class="detail-label">Started:</span> ${formatDateTime(task.started_at)}</div>
            <div class="detail-row"><span class="detail-label">Completed:</span> ${formatDateTime(task.completed_at)}</div>
            <div class="detail-row"><span class="detail-label">Duration:</span> ${formatDuration(task.duration_seconds)}</div>
        `;

        if (task.status === 'failed' && errorMsg) {
            detailsHtml += `<div class="detail-row detail-error"><span class="detail-label">Error:</span> ${errorMsg}</div>`;
        } else if (task.type === 'rip' && (outputDir || outputFile)) {
            if (outputDir) {
                detailsHtml += `<div class="detail-row"><span class="detail-label">Output Dir:</span> ${outputDir}</div>`;
            }
            if (outputFile) {
                detailsHtml += `<div class="detail-row"><span class="detail-label">Output File:</span> ${outputFile}</div>`;
            }
        }

        return `
            <div class="task-item task-${task.status}" onclick="toggleTaskDetails('${task.id}')">
                <div class="task-header">
                    <span class="task-status status-${task.status}">${statusIcon} ${task.status}</span>
                    <span class="task-type">${task.type || 'task'}</span>
                    <span class="task-id" title="${task.id}">${formatTaskId(task.id)}</span>
                    <span class="task-expand" id="expand-${task.id}">&#9660;</span>
                </div>
                <div class="task-details" id="details-${task.id}" style="display: none;">
                    ${detailsHtml}
                </div>
            </div>
        `;
    }).join('');
}

function toggleTaskDetails(taskId) {
    const details = document.getElementById(`details-${taskId}`);
    const expand = document.getElementById(`expand-${taskId}`);

    if (details.style.display === 'none') {
        details.style.display = 'block';
        expand.innerHTML = '&#9650;';
    } else {
        details.style.display = 'none';
        expand.innerHTML = '&#9660;';
    }
}

function toggleQueuedTaskDetails(taskId) {
    const details = document.getElementById(`details-queued-${taskId}`);
    const expand = document.getElementById(`expand-queued-${taskId}`);

    if (details.style.display === 'none') {
        details.style.display = 'block';
        expand.innerHTML = '&#9650;';
        expandedQueuedTasks.add(taskId);
    } else {
        details.style.display = 'none';
        expand.innerHTML = '&#9660;';
        expandedQueuedTasks.delete(taskId);
    }
}

function toggleCompleted() {
    const container = document.getElementById('completed-tasks');
    container.classList.toggle('collapsed');
}

function updatePauseUI() {
    const banner = document.getElementById('paused-banner');
    const btn = document.getElementById('pause-btn');

    if (isPaused) {
        banner.style.display = 'block';
        btn.textContent = 'Resume Queue';
        btn.classList.add('btn-primary');
        btn.classList.remove('btn-secondary');
    } else {
        banner.style.display = 'none';
        btn.textContent = 'Pause Queue';
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');
    }
}

async function togglePause() {
    const btn = document.getElementById('pause-btn');
    btn.disabled = true;

    try {
        const endpoint = isPaused ? '/api/tasks/resume' : '/api/tasks/pause';
        const response = await fetch(endpoint, { method: 'POST' });

        if (response.ok) {
            // Optimistic update
            isPaused = !isPaused;
            updatePauseUI();
        } else {
            const error = await response.json();
            alert('Failed to ' + (isPaused ? 'resume' : 'pause') + ' queue: ' + (error.detail || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error toggling pause:', error);
        alert('Error toggling queue pause state');
    } finally {
        btn.disabled = false;
    }
}

// Listen for progress updates via WebSocket
document.addEventListener('amphigory:progress', (e) => {
    const data = e.detail;
    const progressBar = document.getElementById(`progress-${data.task_id}`);
    const progressText = document.getElementById(`progress-text-${data.task_id}`);

    if (progressBar) {
        progressBar.style.width = `${data.percent}%`;
    }
    if (progressText) {
        let text = `${data.percent}%`;
        if (data.eta_seconds) {
            const mins = Math.floor(data.eta_seconds / 60);
            const secs = data.eta_seconds % 60;
            text += ` - ${mins}:${secs.toString().padStart(2, '0')} remaining`;
        }
        progressText.textContent = text;
    }
});

// Listen for pause state changes via WebSocket
document.addEventListener('amphigory:queue_paused', (e) => {
    isPaused = e.detail.paused;
    updatePauseUI();
});

// Refresh periodically
function startPolling() {
    loadTasks();
    loadFailedTasks();
    setInterval(loadTasks, 5000);
    setInterval(loadFailedTasks, 10000);
}

document.addEventListener('DOMContentLoaded', startPolling);
</script>
{% endblock %}
