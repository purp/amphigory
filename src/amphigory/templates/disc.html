{% extends "base.html" %}

{% block title %}Disc Review - Amphigory{% endblock %}

{% block content %}
<div class="disc-review">
    <header class="page-header">
        <h1>Disc Review</h1>
        <p class="subtitle" id="disc-status-text">Loading...</p>
    </header>

    <section class="scan-section card" id="scan-section">
        <div id="scan-status">
            <p class="text-muted">Checking for disc...</p>
        </div>
    </section>

    <section class="disc-info card" id="disc-info-section" style="display: none;">
        <h3>Disc Information</h3>
        <div class="form-row">
            <label for="disc-title">Title:</label>
            <div style="display: flex; gap: 0.5rem; flex: 1;">
                <input type="text" id="disc-title" name="disc_title"
                       class="setting-input" placeholder="Enter disc title">
                <button type="button" class="btn btn-small" onclick="searchTMDB()">Search TMDB</button>
            </div>
        </div>
        <div id="tmdb-results" class="tmdb-results" style="display: none;">
            <!-- TMDB results populated via JavaScript -->
        </div>
        <div class="form-row">
            <label for="disc-year">Year:</label>
            <input type="number" id="disc-year" name="disc_year"
                   class="setting-input setting-input-small" placeholder="YYYY"
                   min="1900" max="2100">
            <button type="button" class="btn btn-secondary" id="save-disc-info-btn" onclick="saveDiscInfo()" disabled>
                Save Disc Info
            </button>
        </div>
        <div class="form-row" id="metadata-links-row" style="display: none;">
            <label>Metadata:</label>
            <div id="metadata-links">
                <!-- Populated by JS: TMDB link | IMDB link -->
            </div>
        </div>
        <div class="form-row">
            <label for="disc-folder">Disc Folder:</label>
            <input type="text" id="disc-folder" name="disc_folder"
                   class="setting-input" placeholder="Auto-generated from title">
        </div>
        <div class="form-row">
            <label></label>
            <button type="button" class="btn btn-small" onclick="setTrackNames()">Set Track Names</button>
        </div>
    </section>

    <section class="tracks-section card" id="tracks-section" style="display: none;">
        <div class="tracks-header">
            <h2>Tracks</h2>
            <div class="track-actions">
                <button type="button" class="btn btn-small" onclick="selectMain()">Select Main Feature</button>
            </div>
        </div>

        <form id="rip-form" onsubmit="submitRipTasks(event)">
            <table class="tracks-table">
                <thead>
                    <tr>
                        <th class="col-drag"></th>
                        <th class="col-select"><input type="checkbox" id="select-all-checkbox" onchange="toggleAll(this)"></th>
                        <th class="col-track">#</th>
                        <th class="col-duration">Duration</th>
                        <th class="col-size">Size</th>
                        <th class="col-resolution">Resolution</th>
                        <th class="col-preset">Transcoding Preset</th>
                        <th class="col-type">Type</th>
                        <th class="col-name">Track Name</th>
                        <th class="col-as" title="Audio and subtitle track counts">A/S</th>
                        <th class="col-status">Status</th>
                    </tr>
                </thead>
                <tbody id="tracks-body">
                    <!-- Tracks populated via JavaScript -->
                </tbody>
            </table>

            <div class="form-actions">
                <button type="button" class="btn btn-secondary" id="save-tracks-btn" onclick="saveTrackInfo()" disabled>
                    Save Track Info
                </button>
                <button type="submit" class="btn btn-primary" id="rip-button" disabled>
                    Process Selected Tracks
                </button>
                <span class="selected-count" id="selected-count">0 tracks selected</span>
            </div>
        </form>
    </section>
</div>

<script>
let scanResult = null;
let draggedRow = null;
let presetData = null;

// HTML escaping to prevent XSS
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Plex naming helper functions (mirror Python naming.py logic)
// Note: Plex suffixes removed - extras go in subdirectories so suffixes are redundant

function sanitizeFilename(name) {
    // Check for null/undefined
    if (!name) return '';

    // Remove invalid filename characters
    const invalidChars = '<>:"/\\|?*';
    let result = name;
    for (const char of invalidChars) {
        result = result.split(char).join('');
    }
    return result;
}

function generateDiscFolder() {
    const title = document.getElementById('disc-title').value.trim();
    const year = document.getElementById('disc-year').value.trim();
    const imdbId = window.selectedIMDBId;

    if (!title || !year) return '';

    let folder = sanitizeFilename(`${title} (${year})`);
    if (imdbId) {
        folder += ` {imdb-${imdbId}}`;
    }
    return folder;
}

function generateTrackFilename(trackType, movieTitle, year, trackName, language) {
    // Check for null/undefined inputs
    if (!movieTitle || !year || !trackName) {
        console.error('Missing required parameters for generateTrackFilename');
        return 'unknown.mkv';
    }

    // Sanitize inputs
    const sanitizedTitle = sanitizeFilename(movieTitle);
    const sanitizedTrackName = sanitizeFilename(trackName);

    // Main feature naming
    if (trackType === 'main_feature') {
        // Check if this is an alternate language version (not en/en-us/english)
        if (language && !['en', 'en-us', 'english'].includes(language.toLowerCase())) {
            return `${sanitizedTitle} (${year}) - ${language}.mkv`;
        } else {
            return `${sanitizedTitle} (${year}).mkv`;
        }
    }

    // Feature (alternate version) naming: use the track name which includes {edition-alternate N}
    if (trackType === 'feature') {
        return `${sanitizedTrackName}.mkv`;
    }

    // Extras naming: "Track Name.mkv" (no suffix needed since extras go in subdirectories)
    return `${sanitizedTrackName}.mkv`;
}

// Preset management
let presetsLoadedPromise = null;

async function loadPresets() {
    try {
        const response = await fetch('/api/presets');
        if (response.ok) {
            presetData = await response.json();
            console.log('Presets loaded:', presetData);
        } else {
            console.error('Failed to load presets:', response.status);
        }
    } catch (error) {
        console.error('Error loading presets:', error);
    }
}

function populateAllPresetDropdowns() {
    if (!presetData || !scanResult || !scanResult.tracks) return;

    document.querySelectorAll('.preset-select').forEach((select, index) => {
        const track = scanResult.tracks[index];
        if (track) {
            populatePresetDropdown(select, track.resolution);
        }
    });
}

function getRecommendedPreset(resolution) {
    // Parse resolution and recommend based on dimensions
    if (!resolution) return 'dvd';

    const match = resolution.match(/(\d+)x(\d+)/);
    if (!match) return 'dvd';

    const width = parseInt(match[1]);
    const height = parseInt(match[2]);

    // Same logic as preset_selector.py
    if (width >= 3840 || height >= 2160) return 'uhd';
    if (width >= 1920 || height >= 1080) return 'bluray';
    return 'dvd';
}

function populatePresetDropdown(selectElement, trackResolution) {
    if (!presetData) return;

    const recommendedCategory = getRecommendedPreset(trackResolution);
    // Try both "uhd" and "uhd4k" for UHD content
    const activePreset = presetData.active[recommendedCategory] ||
                         presetData.active[recommendedCategory + '4k'];

    selectElement.innerHTML = presetData.presets.map(preset => {
        const selected = preset.name === activePreset ? ' selected' : '';
        // Abbreviate: take part before hyphen, trim whitespace
        const abbrev = preset.name.includes(' - ')
            ? preset.name.split(' - ')[0].trim()
            : preset.name;
        return `<option value="${escapeHtml(preset.name)}"${selected}>${escapeHtml(abbrev)}</option>`;
    }).join('');
}

// Drag and drop handlers
function handleDragStart(e) {
    // Don't start drag from input fields - allow text selection
    const tag = e.target.tagName.toLowerCase();
    if (tag === 'input' || tag === 'select' || tag === 'textarea' || tag === 'button') {
        e.preventDefault();
        return;
    }

    // Clear any stale drag state (e.g., from cancelled drags)
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
    }
    draggedRow = e.target.closest('tr');
    if (draggedRow && draggedRow.classList.contains('track-row')) {
        draggedRow.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const targetRow = e.target.closest('tr');
    if (targetRow && targetRow !== draggedRow && targetRow.classList.contains('track-row')) {
        const tbody = targetRow.parentNode;
        const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
        const draggedIdx = rows.indexOf(draggedRow);
        const targetIdx = rows.indexOf(targetRow);

        if (draggedIdx >= 0 && targetIdx >= 0) {
            if (draggedIdx < targetIdx) {
                targetRow.after(draggedRow);
            } else {
                targetRow.before(draggedRow);
            }
        }
    }
}

function handleDrop(e) {
    e.preventDefault();
}

function handleDragEnd(e) {
    if (draggedRow) {
        draggedRow.classList.remove('dragging');
        draggedRow = null;
        updateTrackOrder();
    }
}

function updateTrackOrder() {
    // Update scanResult.tracks to match new DOM order
    const tbody = document.getElementById('tracks-body');
    if (!tbody || !scanResult || !scanResult.tracks) return;

    const rows = Array.from(tbody.querySelectorAll('tr.track-row'));
    const newOrder = [];

    for (const row of rows) {
        const input = row.querySelector('input[name="tracks"]');
        if (!input) continue;

        const trackNum = parseInt(input.value);
        if (isNaN(trackNum)) continue;

        const track = scanResult.tracks.find(t => t.number === trackNum);
        if (track) newOrder.push(track);
    }

    if (newOrder.length > 0) {
        scanResult.tracks = newOrder;
    }
}

// Check disc status and show scan button
async function checkDiscStatus() {
    try {
        // First, check if we arrived with a task_id parameter (from dashboard scan)
        const urlParams = new URLSearchParams(window.location.search);
        const taskId = urlParams.get('task_id');

        if (taskId) {
            // We have a task_id - show scanning status and poll for results
            document.getElementById('disc-status-text').textContent = 'Scanning disc...';
            document.getElementById('scan-section').innerHTML = `
                <div class="scanning">
                    <div class="spinner"></div>
                    <p>Scanning disc...</p>
                </div>
            `;
            // Clear the task_id from URL to prevent re-polling on refresh
            window.history.replaceState({}, document.title, '/disc');
            pollForScanResult(taskId);
            return;
        }

        // Check if there's an in-progress scan task
        try {
            const scanStatusResponse = await fetch('/api/disc/scan-status');
            if (scanStatusResponse.ok) {
                const scanStatus = await scanStatusResponse.json();
                // There's an active scan - show scanning UI and poll for it
                document.getElementById('disc-status-text').textContent = 'Scanning disc...';
                document.getElementById('scan-section').innerHTML = `
                    <div class="scanning">
                        <div class="spinner"></div>
                        <p>Scanning disc...</p>
                    </div>
                `;
                pollForScanResult(scanStatus.task_id);
                return;
            }
        } catch (err) {
            // No active scan - continue to normal status check
        }

        const response = await fetch('/api/disc/status');
        const data = await response.json();

        const statusText = document.getElementById('disc-status-text');
        const scanSection = document.getElementById('scan-section');

        if (data.has_disc) {
            // Check if we have cached scan results in memory
            try {
                const scanResponse = await fetch('/api/disc/current-scan');
                if (scanResponse.ok) {
                    scanResult = await scanResponse.json();
                    displayScanResult(scanResult);
                    return;
                }
            } catch (err) {
                // No cached scan in memory - check database by fingerprint
            }

            // Check if disc is known in database by fingerprint
            try {
                const lookupResponse = await fetch('/api/disc/lookup-fingerprint');
                if (lookupResponse.ok) {
                    const discInfo = await lookupResponse.json();
                    // Check if disc has an ID (exists in database)
                    if (discInfo.id) {
                        // Known disc - auto-load from database
                        const fingerprint = discInfo.fingerprint;
                        const fpShort = fingerprint ? ` (${fingerprint.substring(0, 7)})` : '';
                        statusText.textContent = `Known disc: ${discInfo.title || 'Unknown'}${fpShort}`;
                        const scannedDate = discInfo.scanned_at ? new Date(discInfo.scanned_at).toLocaleDateString() : 'previously';
                        scanSection.innerHTML = `
                            <p class="text-muted">Previously scanned on ${scannedDate}</p>
                            <button class="btn btn-primary" onclick="loadFromDatabase('${fingerprint}')">
                                Reload from DB
                            </button>
                            <button class="btn btn-secondary" onclick="startScan()" style="margin-left: 0.5rem;">
                                Rescan Disc
                            </button>
                        `;
                        // Store disc info for later use
                        window.knownDiscInfo = discInfo;
                        // Auto-load from database
                        loadFromDatabase(fingerprint);
                        return;
                    }
                }
            } catch (err) {
                // Disc not in database - continue to show scan button
            }

            // No cached scan - show scan button
            statusText.textContent = `Disc: ${data.volume_name || 'Unknown'} (${data.device_path})`;
            scanSection.innerHTML = `
                <button class="btn btn-primary" onclick="startScan()">
                    Scan Disc
                </button>
                <span class="text-muted" style="margin-left: 1rem;">Click to analyze disc contents</span>
            `;
        } else {
            statusText.textContent = 'No disc detected';
            scanSection.innerHTML = `
                <p class="text-muted">Insert a disc and click refresh to scan.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Refresh</button>
            `;

            // Clear scan result and hide sections
            scanResult = null;
            document.getElementById('disc-info-section').style.display = 'none';
            document.getElementById('tracks-section').style.display = 'none';
        }
    } catch (error) {
        console.error('Error checking disc status:', error);
        document.getElementById('disc-status-text').textContent = 'Error checking disc status';
    }
}

// Load cached scan data from database (legacy - kept for compatibility)
function loadCachedScan() {
    if (!window.knownDiscInfo || !window.knownDiscInfo.scan_data) {
        console.error('No cached scan data available');
        return;
    }

    scanResult = window.knownDiscInfo.scan_data;
    displayScanResult(scanResult);
}

// Load disc and tracks from database by fingerprint
async function loadFromDatabase(fingerprint) {
    try {
        const response = await fetch(`/api/disc/by-fingerprint/${fingerprint}`);
        if (!response.ok) {
            console.error('Failed to load disc from database:', response.status);
            return;
        }

        const data = await response.json();
        const disc = data.disc;
        const tracks = data.tracks;

        // Store disc ID for later saving
        window.currentDiscId = disc.id;

        // Populate disc info fields
        if (disc.title) {
            document.getElementById('disc-title').value = disc.title;
        }
        if (disc.year) {
            document.getElementById('disc-year').value = disc.year;
        }
        if (disc.tmdb_id) {
            window.selectedTMDBId = disc.tmdb_id;
        }
        if (disc.imdb_id) {
            window.selectedIMDBId = disc.imdb_id;
        }

        // Show metadata links if we have IDs
        if (disc.tmdb_id || disc.imdb_id) {
            showMetadataLinks(disc.title, disc.tmdb_id, disc.imdb_id);
        }

        // Build scanResult-compatible structure for setTrackNames() and other functions
        scanResult = {
            fingerprint: disc.fingerprint,
            disc_name: disc.title,
            disc_type: disc.disc_type,
            tracks: tracks.map(t => ({
                number: t.track_number,
                duration: formatDuration(t.duration_seconds),
                duration_seconds: t.duration_seconds,
                size_bytes: t.size_bytes,
                classification: t.track_type,
                confidence: t.classification_confidence,
                resolution: t.resolution,
                audio_streams: t.audio_tracks || [],
                subtitle_streams: t.subtitle_tracks || [],
            }))
        };

        // Show disc info section
        document.getElementById('disc-info-section').style.display = 'block';

        // Show tracks section
        document.getElementById('tracks-section').style.display = 'block';

        // Display tracks from database with status verification
        await displayTracksFromDatabase(tracks);

        // Enable save button since we have disc data
        enableSaveButton();

    } catch (error) {
        console.error('Error loading disc from database:', error);
    }
}

// Display tracks loaded from database with file verification
async function displayTracksFromDatabase(tracks) {
    const tbody = document.getElementById('tracks-body');
    tbody.innerHTML = '';

    // Sort tracks: main_feature first, then by duration descending
    tracks.sort((a, b) => {
        // Main features first
        if (a.track_type === 'main_feature' && b.track_type !== 'main_feature') return -1;
        if (b.track_type === 'main_feature' && a.track_type !== 'main_feature') return 1;
        // Then by duration descending
        return (b.duration_seconds || 0) - (a.duration_seconds || 0);
    });

    // Verify file existence for each track in parallel
    const verificationPromises = tracks.map(async (track) => {
        try {
            const response = await fetch(`/api/tracks/${track.id}/verify-files`);
            if (response.ok) {
                return { track, verification: await response.json() };
            }
        } catch (error) {
            console.error(`Error verifying files for track ${track.id}:`, error);
        }
        // Return default verification if API call fails
        return {
            track,
            verification: {
                ripped_exists: false,
                transcoded_exists: false,
                inserted_exists: false,
                ripped_path: track.ripped_path,
                transcoded_path: track.transcoded_path,
                inserted_path: track.inserted_path
            }
        };
    });

    const results = await Promise.all(verificationPromises);

    // Build track rows
    for (const { track, verification } of results) {
        // Determine processing status
        const rippedExists = verification.ripped_exists;
        const transcodedExists = verification.transcoded_exists;
        const insertedExists = verification.inserted_exists;

        const isFullyProcessed = insertedExists;
        const isPartiallyProcessed = (rippedExists || transcodedExists) && !insertedExists;
        const isUnprocessed = !rippedExists && !transcodedExists && !insertedExists;

        const shouldSelect = isUnprocessed || isPartiallyProcessed;
        const showReset = isPartiallyProcessed;

        const row = createTrackRowFromDb(track, verification, shouldSelect, showReset);
        tbody.appendChild(row);
    }

    // After rendering tracks, populate preset dropdowns
    document.querySelectorAll('.preset-select').forEach((select) => {
        const trackId = parseInt(select.dataset.trackId);
        const track = tracks.find(t => t.id === trackId);
        if (track) {
            populatePresetDropdown(select, track.resolution);
            // If track has a saved preset, select it
            if (track.preset_name) {
                select.value = track.preset_name;
            }
        }
    });

    updateSelectedCount();
    enableSaveTracksButton();
}

// Create a track row from database track data
function createTrackRowFromDb(track, verification, shouldSelect, showReset) {
    const row = document.createElement('tr');
    row.className = 'track-row' + (track.track_type === 'main_feature' ? ' main-feature' : '');
    row.draggable = true;
    row.dataset.trackId = track.id;

    // Drag handlers
    row.ondragstart = handleDragStart;
    row.ondragover = handleDragOver;
    row.ondrop = handleDrop;
    row.ondragend = handleDragEnd;

    // Build status icons
    const rippedStatus = getStatusClass(track.ripped_path, verification.ripped_exists);
    const transcodedStatus = getStatusClass(track.transcoded_path, verification.transcoded_exists);
    const insertedStatus = getStatusClass(track.inserted_path, verification.inserted_exists);

    // Reset link HTML
    const resetLinkHtml = showReset
        ? `<a href="#" class="reset-link" onclick="resetTrack(${track.id}); return false;" title="Reset track progress">&#8634;</a>`
        : '';

    row.innerHTML = `
        <td class="col-drag"><span class="drag-handle">&#8942;&#8942;</span></td>
        <td class="col-select">
            <input type="checkbox" name="tracks" value="${track.track_number}"
                   ${shouldSelect ? 'checked' : ''}
                   onchange="updateSelectedCount()" data-classification="${escapeHtml(track.track_type || 'unknown')}"
                   data-track-id="${track.id}">
        </td>
        <td class="col-track">${track.track_number}</td>
        <td class="col-duration">${formatDuration(track.duration_seconds)}</td>
        <td class="col-size">${formatSize(track.size_bytes)}</td>
        <td class="col-resolution">${escapeHtml(track.resolution || '-')}</td>
        <td class="col-preset">
            <select class="preset-select" data-track-id="${track.id}">
                <!-- Options populated by displayTracksFromDatabase -->
            </select>
        </td>
        <td class="col-type">
            <select class="track-type-select type-${track.track_type || 'unknown'}"
                    onchange="updateTrackClassificationFromDb(this, ${track.id})"
                    data-track-id="${track.id}">
                ${getTrackTypeOptions(track.track_type || 'unknown')}
            </select>
        </td>
        <td class="col-name">
            <input type="text" name="track_name_${track.track_number}"
                   class="track-name-input"
                   value="${escapeHtml(track.track_name || '')}"
                   data-track-id="${track.id}">
        </td>
        <td class="col-as">${Array.isArray(track.audio_tracks) ? track.audio_tracks.length : (track.audio_tracks || 0)}/${Array.isArray(track.subtitle_tracks) ? track.subtitle_tracks.length : (track.subtitle_tracks || 0)}</td>
        <td class="track-status">
            <span class="status-icon ${rippedStatus}" title="${getStatusTitle('ripped', rippedStatus)}">&#128191;</span>
            <span class="status-icon ${transcodedStatus}" title="${getStatusTitle('transcoded', transcodedStatus)}">&#127916;</span>
            <span class="status-icon ${insertedStatus}" title="${getStatusTitle('inserted', insertedStatus)}">&#128250;</span>
            ${resetLinkHtml}
        </td>
    `;

    return row;
}

// Get CSS class for status icon based on path and file existence
function getStatusClass(path, exists) {
    if (!path) {
        return 'pending';  // Path is null - not done yet
    }
    if (exists) {
        return 'done';     // Path is set and file exists
    }
    return 'missing';      // Path is set but file doesn't exist (data loss)
}

// Get hover title text for status icon
function getStatusTitle(statusType, statusClass) {
    const labels = {
        ripped: { pending: 'Not ripped', done: 'Ripped', missing: 'Ripped file missing' },
        transcoded: { pending: 'Not transcoded', done: 'Transcoded', missing: 'Transcoded file missing' },
        inserted: { pending: 'Not inserted', done: 'Inserted', missing: 'Inserted file missing' },
    };
    return labels[statusType]?.[statusClass] || statusType;
}

// Update track classification for database-loaded tracks
function updateTrackClassificationFromDb(selectElement, trackId) {
    const newClassification = selectElement.value;

    // Update visual styling on the row
    const row = selectElement.closest('tr');
    if (!row) {
        console.error('Could not find parent row for track select');
        return;
    }

    row.classList.remove('main-feature');
    if (newClassification === 'main_feature') {
        row.classList.add('main-feature');
    }

    // Update select element class
    selectElement.className = `track-type-select type-${newClassification}`;

    // Update checkbox data attribute
    const checkbox = row.querySelector('input[name="tracks"]');
    if (checkbox) {
        checkbox.dataset.classification = newClassification;
    }

    // TODO: Could optionally save to database here
}

// Reset a track's progress (delete files and clear paths)
async function resetTrack(trackId) {
    if (!confirm('Reset this track? This will delete any ripped/transcoded files and clear progress.')) {
        return;
    }

    try {
        const response = await fetch(`/api/tracks/${trackId}/reset`, {
            method: 'POST'
        });

        if (response.ok) {
            // Reload from database to refresh display
            const fingerprint = window.knownDiscInfo?.fingerprint;
            if (fingerprint) {
                await loadFromDatabase(fingerprint);
            } else {
                // Fallback: just refresh the page
                window.location.reload();
            }
        } else {
            const error = await response.json();
            alert('Failed to reset track: ' + (error.detail || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error resetting track:', error);
        alert('Failed to reset track: ' + error.message);
    }
}

// Start a scan
async function startScan() {
    const scanSection = document.getElementById('scan-section');
    scanSection.innerHTML = `
        <div class="scanning">
            <div class="spinner"></div>
            <p>Scanning disc...</p>
        </div>
    `;

    try {
        const response = await fetch('/api/disc/scan', { method: 'POST' });
        const data = await response.json();

        // Poll for results
        pollForScanResult(data.task_id);
    } catch (error) {
        console.error('Error starting scan:', error);
        scanSection.innerHTML = `
            <p class="error">Error starting scan. Please try again.</p>
            <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
        `;
    }
}

// Poll for scan result
async function pollForScanResult(taskId) {
    const maxAttempts = 300;  // 300 × 2s = 10 minutes
    let attempts = 0;

    const poll = async () => {
        try {
            // Pass task_id to only get result for THIS scan, not stale cached results
            const response = await fetch(`/api/disc/scan-result?task_id=${encodeURIComponent(taskId)}`);
            if (response.ok) {
                scanResult = await response.json();
                displayScanResult(scanResult);
                return;
            }
            // 404 means task not complete yet - keep polling
        } catch (error) {
            console.log('Waiting for scan result...');
        }

        attempts++;
        if (attempts < maxAttempts) {
            setTimeout(poll, 2000);
        } else {
            document.getElementById('scan-section').innerHTML = `
                <p class="error">Scan timed out. Please try again.</p>
                <button class="btn btn-secondary" onclick="checkDiscStatus()">Retry</button>
            `;
        }
    };

    poll();
}

// Show metadata links (TMDB/IMDB) for saved disc
function showMetadataLinks(title, tmdbId, imdbId) {
    const metadataLinksRow = document.getElementById('metadata-links-row');
    const metadataLinksDiv = document.getElementById('metadata-links');
    if (!metadataLinksDiv) return;

    metadataLinksDiv.innerHTML = '';

    if (tmdbId) {
        metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
        const tmdbLink = document.createElement('a');
        tmdbLink.href = `https://www.themoviedb.org/movie/${tmdbId}`;
        tmdbLink.target = '_blank';
        tmdbLink.textContent = title || 'TMDB';
        tmdbLink.style.marginRight = '0.5rem';
        metadataLinksDiv.appendChild(tmdbLink);
    }

    if (imdbId) {
        if (tmdbId) {
            metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
        } else {
            metadataLinksDiv.appendChild(document.createTextNode('IMDB: '));
        }
        const imdbLink = document.createElement('a');
        imdbLink.href = `https://www.imdb.com/title/${imdbId}`;
        imdbLink.target = '_blank';
        imdbLink.textContent = imdbId;
        metadataLinksDiv.appendChild(imdbLink);
    }

    if (tmdbId || imdbId) {
        metadataLinksRow.style.display = 'flex';
    }
}

// Display scan results
async function displayScanResult(result) {
    scanResult = result;

    // Check for saved metadata
    if (result.fingerprint) {
        try {
            const metaResponse = await fetch(`/api/disc/metadata/${result.fingerprint}`);
            if (metaResponse.ok) {
                const metadata = await metaResponse.json();
                if (metadata.title) {
                    document.getElementById('disc-title').value = metadata.title;
                }
                if (metadata.year) {
                    document.getElementById('disc-year').value = metadata.year;
                }
                if (metadata.tmdb_id) {
                    window.selectedTMDBId = metadata.tmdb_id;
                }
                if (metadata.imdb_id) {
                    window.selectedIMDBId = metadata.imdb_id;
                }
                // Show metadata links if we have IDs
                if (metadata.tmdb_id || metadata.imdb_id) {
                    showMetadataLinks(metadata.title, metadata.tmdb_id, metadata.imdb_id);
                }
            }
        } catch (error) {
            console.log('No saved metadata for disc');
        }
    }

    // Use textContent for text nodes to prevent XSS
    document.getElementById('disc-status-text').textContent = `${result.disc_name || 'Unknown'} (${result.disc_type || 'Unknown'})`;

    const scanSection = document.getElementById('scan-section');

    // Show duplicate removal info if available
    const dedupeInfo = result.duplicates_removed ? ` (${result.duplicates_removed} duplicate${result.duplicates_removed !== 1 ? 's' : ''} removed)` : '';

    scanSection.innerHTML = `
        <p class="scan-complete">Scan complete! Found ${result.tracks.length} track${result.tracks.length !== 1 ? 's' : ''}.${dedupeInfo}</p>
        <button class="btn btn-secondary" onclick="startScan()">Rescan</button>
    `;

    // Show disc info section
    const infoSection = document.getElementById('disc-info-section');
    infoSection.style.display = 'block';

    // Populate title only if not already set from saved metadata
    const titleInput = document.getElementById('disc-title');
    if (!titleInput.value) {
        titleInput.value = result.disc_name || '';
    }

    const tracksSection = document.getElementById('tracks-section');
    tracksSection.style.display = 'block';

    const tbody = document.getElementById('tracks-body');
    tbody.innerHTML = result.tracks.map((track, index) => `
        <tr class="track-row ${track.classification === 'main_feature' ? 'main-feature' : ''}"
            draggable="true"
            data-track-index="${index}"
            ondragstart="handleDragStart(event)"
            ondragover="handleDragOver(event)"
            ondrop="handleDrop(event)"
            ondragend="handleDragEnd(event)">
            <td class="col-drag"><span class="drag-handle">⋮⋮</span></td>
            <td class="col-select">
                <input type="checkbox" name="tracks" value="${track.number || index}"
                       onchange="updateSelectedCount()" data-classification="${escapeHtml(track.classification || 'unknown')}">
            </td>
            <td class="col-track">${track.number || index}</td>
            <td class="col-duration">${escapeHtml(track.duration || '-')}</td>
            <td class="col-size">${formatSize(track.size_bytes)}</td>
            <td class="col-resolution">${escapeHtml(track.resolution || '-')}</td>
            <td class="col-preset">
                <select class="preset-select" data-track-index="${index}">
                    <!-- Options populated by loadPresets() -->
                </select>
            </td>
            <td class="col-type">
                <select class="track-type-select type-${track.classification || 'unknown'}"
                        onchange="updateTrackClassification(this, ${index})"
                        data-track-index="${index}">
                    ${getTrackTypeOptions(track.classification || 'unknown')}
                </select>${getConfidenceIndicator(track.confidence)}
            </td>
            <td class="col-name">
                <input type="text" name="track_name_${track.number || index}"
                       class="track-name-input"
                       placeholder="${escapeHtml(getDefaultTrackName(track))}"
                       value="${escapeHtml(track.name || '')}">
            </td>
            <td class="col-as">${Array.isArray(track.audio_streams) ? track.audio_streams.length : (track.audio_streams || 0)}/${Array.isArray(track.subtitle_streams) ? track.subtitle_streams.length : (track.subtitle_streams || 0)}</td>
            <td class="track-status">
                <span class="status-icon pending" title="Ripped">&#128191;</span>
                <span class="status-icon pending" title="Transcoded">&#127916;</span>
                <span class="status-icon pending" title="Inserted">&#128250;</span>
            </td>
        </tr>
    `).join('');

    // After rendering tracks, populate preset dropdowns
    populateAllPresetDropdowns();

    updateSelectedCount();
}

function formatSize(bytes) {
    if (!bytes) return '-';
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(1) + ' GB';
}

function formatDuration(seconds) {
    if (!seconds) return '-';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    if (hours > 0) {
        return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
    return `${minutes}:${String(secs).padStart(2, '0')}`;
}

function formatClassification(classification) {
    const labels = {
        'main_feature': 'Main Feature',
        'feature': 'Feature',
        'behind_the_scenes': 'Behind The Scenes',
        'deleted_scenes': 'Deleted Scene',
        'featurettes': 'Featurette',
        'interviews': 'Interview',
        'scenes': 'Scene',
        'shorts': 'Short',
        'trailers': 'Trailer',
        'other': 'Other',
        'unknown': 'Unknown',
    };
    return labels[classification] || classification || 'Unknown';
}

function getTrackTypeOptions(currentClassification) {
    const types = [
        'main_feature',
        'feature',
        'behind_the_scenes',
        'deleted_scenes',
        'featurettes',
        'interviews',
        'scenes',
        'shorts',
        'trailers',
        'other',
    ];

    return types.map(type => {
        const selected = type === currentClassification ? ' selected' : '';
        return `<option value="${type}"${selected}>${formatClassification(type)}</option>`;
    }).join('');
}

function updateTrackClassification(selectElement, trackIndex) {
    if (!scanResult || !scanResult.tracks || !scanResult.tracks[trackIndex]) {
        console.error('Invalid track index:', trackIndex);
        return;
    }

    const newClassification = selectElement.value;
    scanResult.tracks[trackIndex].classification = newClassification;

    // Remove confidence indicator when user manually changes classification
    const row = selectElement.closest('tr');
    if (!row) {
        console.error('Could not find parent row for track select');
        return;
    }

    const confidenceSpan = row.querySelector('.confidence');
    if (confidenceSpan) {
        confidenceSpan.remove();
    }

    // Update select element class to reflect new classification
    selectElement.className = `track-type-select type-${newClassification}`;

    // Update visual styling on the row
    row.classList.remove('main-feature');
    if (newClassification === 'main_feature') {
        row.classList.add('main-feature');
    }

    // Update checkbox data attribute
    const checkbox = row.querySelector('input[name="tracks"]');
    if (checkbox) {
        checkbox.dataset.classification = newClassification;
    }
}

function getConfidenceIndicator(confidence) {
    if (confidence === 'high') {
        return '<span class="confidence confidence-high">●●●</span>';
    } else if (confidence === 'medium') {
        return '<span class="confidence confidence-medium">●●○</span>';
    } else if (confidence === 'low') {
        return '<span class="confidence confidence-low">●○○</span>';
    }
    return '';
}

function getDefaultTrackName(track) {
    const classification = track.classification || 'unknown';

    if (classification === 'main_feature') {
        return 'Main Feature';
    } else if (classification === 'feature') {
        return 'Feature';
    } else if (classification === 'trailers') {
        return 'Trailer';
    } else if (classification === 'featurettes') {
        return 'Featurette';
    } else if (classification === 'behind_the_scenes') {
        return 'Behind The Scenes';
    } else if (classification === 'deleted_scenes') {
        return 'Deleted Scene';
    } else if (classification === 'interviews') {
        return 'Interview';
    } else if (classification === 'scenes') {
        return 'Scene';
    } else if (classification === 'shorts') {
        return 'Short';
    } else {
        return 'Extra';
    }
}

function selectAll() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = true);
    updateSelectedCount();
}

function selectNone() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = false);
    updateSelectedCount();
}

function selectMain() {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => {
        cb.checked = cb.dataset.classification === 'main_feature';
    });
    updateSelectedCount();
}

function toggleAll(masterCheckbox) {
    document.querySelectorAll('input[name="tracks"]').forEach(cb => cb.checked = masterCheckbox.checked);
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('input[name="tracks"]:checked').length;
    document.getElementById('selected-count').textContent = `${selected} track${selected !== 1 ? 's' : ''} selected`;
    document.getElementById('rip-button').disabled = selected === 0;

    // Update master checkbox
    const total = document.querySelectorAll('input[name="tracks"]').length;
    const masterCheckbox = document.getElementById('select-all-checkbox');
    masterCheckbox.checked = selected === total && total > 0;
    masterCheckbox.indeterminate = selected > 0 && selected < total;
}

async function submitRipTasks(event) {
    event.preventDefault();

    // Task 11: Save all page data to database first
    if (window.currentDiscId) {
        const discData = {
            title: document.getElementById('disc-title').value,
            year: parseInt(document.getElementById('disc-year').value) || null,
            imdb_id: window.selectedIMDBId || null,
        };

        const tracksData = [];
        document.querySelectorAll('.track-row').forEach(row => {
            const trackId = row.dataset.trackId;
            if (trackId) {
                tracksData.push({
                    id: parseInt(trackId),
                    track_name: row.querySelector('.track-name-input')?.value,
                    track_type: row.querySelector('.track-type-select')?.value,
                    preset_name: row.querySelector('.preset-select')?.value,
                });
            }
        });

        try {
            await fetch(`/api/disc/${window.currentDiscId}/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ disc: discData, tracks: tracksData }),
            });
            console.log('Saved disc and track data to database');
        } catch (error) {
            console.error('Error saving to database:', error);
        }
    }

    // Save disc metadata first (if we have TMDB/IMDB data) - legacy path for fingerprint-based saves
    const fingerprint = scanResult?.fingerprint || window.knownDiscInfo?.fingerprint;
    const title = document.getElementById('disc-title').value.trim();
    const year = document.getElementById('disc-year').value.trim();

    if (fingerprint && title && year && (window.selectedTMDBId || window.selectedIMDBId)) {
        try {
            await fetch('/api/disc/metadata', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    fingerprint: fingerprint,
                    tmdb_id: window.selectedTMDBId || null,
                    imdb_id: window.selectedIMDBId || null,
                    title: title,
                    year: parseInt(year)
                })
            });
        } catch (error) {
            console.error('Failed to save metadata:', error);
            // Continue with processing even if metadata save fails
        }
    }

    const selectedTracks = Array.from(document.querySelectorAll('input[name="tracks"]:checked'))
        .map(cb => parseInt(cb.value));
    const discFolder = document.getElementById('disc-folder').value;
    const discTitle = document.getElementById('disc-title').value;
    const discYear = document.getElementById('disc-year').value;

    if (selectedTracks.length === 0) {
        alert('Please select at least one track to process.');
        return;
    }

    if (!discTitle || !discYear) {
        alert('Please enter a title and year for Plex-compatible naming.');
        return;
    }

    const ripButton = document.getElementById('rip-button');
    ripButton.disabled = true;
    ripButton.textContent = 'Creating tasks...';

    try {
        // Build tracks array for the process endpoint
        const tracksToProcess = [];

        for (const trackNumber of selectedTracks) {
            const row = document.querySelector(`tr.track-row input[value="${trackNumber}"]`)?.closest('tr');
            if (!row) continue;

            const track = scanResult?.tracks?.find(t => (t.number || scanResult.tracks.indexOf(t)) === trackNumber);
            const trackNameInput = document.querySelector(`input[name="track_name_${trackNumber}"]`);
            const trackName = trackNameInput?.value || getDefaultTrackName(track);
            const presetSelect = row.querySelector('.preset-select');

            let trackType = track?.classification || 'other';
            if (trackType === 'extra') {
                trackType = 'other';
            }

            // Generate Plex-compatible filename
            const outputFilename = generateTrackFilename(
                trackType,
                discTitle,
                parseInt(discYear),
                trackName,
                'en'
            );

            tracksToProcess.push({
                track_number: trackNumber,
                output_filename: outputFilename,
                output_directory: discFolder ? discFolder + '/' : null,
                preset: presetSelect?.value || null,
                expected_size_bytes: track?.size_bytes || null,
                expected_duration: track?.duration || null,
            });
        }

        // Verify we have a fingerprint
        if (!fingerprint) {
            alert('No disc fingerprint available. Please scan the disc first.');
            ripButton.disabled = false;
            ripButton.textContent = 'Process Selected Tracks';
            return;
        }

        // Call the process endpoint
        const response = await fetch('/api/tasks/process', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                tracks: tracksToProcess,
                disc_fingerprint: fingerprint,
            }),
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to create tasks');
        }

        const data = await response.json();
        console.log(`Created ${data.tasks.length} tasks (${tracksToProcess.length} tracks × 2 tasks each)`);

        // Redirect to queue page
        window.location.href = '/queue';
    } catch (error) {
        console.error('Error creating tasks:', error);
        alert('Error creating tasks: ' + error.message);
        ripButton.disabled = false;
        ripButton.textContent = 'Process Selected Tracks';
    }
}

// Search TMDB for movie matches
async function searchTMDB() {
    const query = document.getElementById('disc-title').value;
    const year = document.getElementById('disc-year').value;

    if (!query) {
        alert('Please enter a title to search');
        return;
    }

    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.style.display = 'block';
    resultsDiv.innerHTML = '<p class="text-muted" style="padding: 0.75rem;">Searching TMDB...</p>';

    try {
        let url = `/api/disc/search-tmdb?query=${encodeURIComponent(query)}`;
        if (year) {
            url += `&year=${encodeURIComponent(year)}`;
        }

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Search failed');
        }

        const data = await response.json();
        displayTMDBResults(data.results);
    } catch (error) {
        console.error('Error searching TMDB:', error);
        resultsDiv.innerHTML = '<p class="error" style="padding: 0.75rem;">Error searching TMDB. Check if API key is configured.</p>';
    }
}

// Display TMDB search results
function displayTMDBResults(results) {
    const resultsDiv = document.getElementById('tmdb-results');
    resultsDiv.innerHTML = ''; // Clear previous

    if (!results || results.length === 0) {
        const p = document.createElement('p');
        p.className = 'text-muted';
        p.style.padding = '0.75rem';
        p.textContent = 'No results found';
        resultsDiv.appendChild(p);
        return;
    }

    results.forEach(movie => {
        const div = document.createElement('div');
        div.className = 'tmdb-result';
        div.onclick = () => selectTMDBResult(movie.id, movie.title, movie.year);

        const strong = document.createElement('strong');
        strong.textContent = movie.title;
        div.appendChild(strong);

        if (movie.year) {
            div.appendChild(document.createTextNode(` (${movie.year})`));
        }

        if (movie.overview) {
            div.appendChild(document.createElement('br'));
            const span = document.createElement('span');
            span.className = 'text-muted';
            span.style.fontSize = '0.85rem';
            const overview = movie.overview.length > 150
                ? movie.overview.substring(0, 150) + '...'
                : movie.overview;
            span.textContent = overview;
            div.appendChild(span);
        }

        resultsDiv.appendChild(div);
    });
}

// Select a TMDB result and fill in the form
async function selectTMDBResult(tmdbId, title, year) {
    document.getElementById('disc-title').value = title;
    if (year) {
        document.getElementById('disc-year').value = year;
    }

    // Hide results
    document.getElementById('tmdb-results').style.display = 'none';

    // Store TMDB ID for later use (e.g., fetching more metadata)
    window.selectedTMDBId = tmdbId;
    enableSaveButton();

    // Show metadata links row
    const metadataLinksRow = document.getElementById('metadata-links-row');
    const metadataLinksDiv = document.getElementById('metadata-links');
    metadataLinksRow.style.display = 'flex';

    // Create TMDB link immediately
    const tmdbUrl = `https://www.themoviedb.org/movie/${tmdbId}`;
    const tmdbLink = document.createElement('a');
    tmdbLink.href = tmdbUrl;
    tmdbLink.target = '_blank';
    tmdbLink.textContent = title;
    tmdbLink.style.marginRight = '0.5rem';

    // Show initial state with TMDB link and loading message for IMDB
    metadataLinksDiv.innerHTML = '';
    metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
    metadataLinksDiv.appendChild(tmdbLink);
    metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
    const loadingSpan = document.createElement('span');
    loadingSpan.className = 'text-muted';
    loadingSpan.textContent = 'Fetching...';
    metadataLinksDiv.appendChild(loadingSpan);

    // Fetch external IDs to get IMDB ID
    try {
        const response = await fetch(`/api/disc/tmdb-external-ids/${tmdbId}`);
        if (response.ok) {
            const externalIds = await response.json();
            if (externalIds.imdb_id) {
                window.selectedIMDBId = externalIds.imdb_id;
                console.log('IMDB ID:', externalIds.imdb_id);
                document.getElementById('disc-folder').value = generateDiscFolder();

                // Update with IMDB link
                const imdbUrl = `https://www.imdb.com/title/${externalIds.imdb_id}/`;
                const imdbLink = document.createElement('a');
                imdbLink.href = imdbUrl;
                imdbLink.target = '_blank';
                imdbLink.textContent = externalIds.imdb_id;

                // Rebuild the metadata links div with both links
                metadataLinksDiv.innerHTML = '';
                metadataLinksDiv.appendChild(document.createTextNode('TMDB: '));
                metadataLinksDiv.appendChild(tmdbLink);
                metadataLinksDiv.appendChild(document.createTextNode(' | IMDB: '));
                metadataLinksDiv.appendChild(imdbLink);
            } else {
                // No IMDB ID found
                loadingSpan.textContent = 'Not available';
            }
        } else {
            // API call failed
            loadingSpan.textContent = 'Not available';
        }
    } catch (error) {
        console.error('Error fetching external IDs:', error);
        // Update loading message to show error
        loadingSpan.textContent = 'Error fetching';
    }
}

// Set track names based on title, year, and classification
function setTrackNames() {
    const title = document.getElementById('disc-title').value;
    const year = document.getElementById('disc-year').value;

    // Validate inputs
    if (!title || !year) {
        alert('Please enter both a title and year before setting track names.');
        return;
    }

    if (!scanResult || !scanResult.tracks) {
        console.error('No tracks available');
        return;
    }

    // Strip year from title if present to prevent "(1999) (1999)"
    const titleWithoutYear = title.replace(/\s*\(\d{4}\)\s*$/, '');

    // Get IMDB ID if available (set when TMDB result is selected)
    const imdbId = window.selectedIMDBId || null;
    const imdbSuffix = imdbId ? ` {imdb-${imdbId}}` : '';

    // First pass: collect main feature durations
    const mainFeatureDurations = new Set();
    scanResult.tracks.forEach((track) => {
        const classification = track.classification || 'other';
        if (classification === 'main_feature' && track.duration) {
            mainFeatureDurations.add(track.duration);
        }
    });

    // Count each type for numbering
    const typeCounts = {};
    const failedTracks = [];
    let alternateVersionCount = 1; // Start at 1 for the first alternate (main feature is implicit version 1)

    // Process each track
    scanResult.tracks.forEach((track, index) => {
        const classification = track.classification || 'other';
        const trackNumber = track.number || index;
        const nameInput = document.querySelector(`input[name="track_name_${trackNumber}"]`);

        if (!nameInput) {
            console.warn(`No input found for track ${trackNumber}`);
            failedTracks.push(trackNumber);
            return;
        }

        let trackName;

        // Main feature: use title, add part number if multiple
        if (classification === 'main_feature') {
            // Initialize counter for main features if not present
            if (!typeCounts[classification]) {
                typeCounts[classification] = 0;
            }
            typeCounts[classification]++;

            const count = typeCounts[classification];

            // Add " - Part N" only if there are multiple main features
            trackName = `${titleWithoutYear} (${year})${imdbSuffix}`;
            if (count > 1) {
                trackName += ` - Part ${count}`;
            }
        } else if (classification === 'feature' || (track.duration && mainFeatureDurations.has(track.duration))) {
            // Feature or alternate version: use Plex-compatible edition tag
            alternateVersionCount++;
            trackName = `${titleWithoutYear} (${year})${imdbSuffix} {edition-alternate ${alternateVersionCount}}`;
        } else {
            // Extras: use getDefaultTrackName() as base, then add count
            const baseName = getDefaultTrackName(track);

            // Initialize counter for this type if not present
            if (!typeCounts[classification]) {
                typeCounts[classification] = 0;
            }
            typeCounts[classification]++;

            const count = typeCounts[classification];
            trackName = `${baseName} ${count}`;
        }

        // Set the track name input value
        nameInput.value = trackName;
    });

    // Show alert if any tracks failed
    if (failedTracks.length > 0) {
        alert(`Warning: Could not set names for ${failedTracks.length} track(s): ${failedTracks.join(', ')}`);
    }
}

// Save disc info to database
async function saveDiscInfo() {
    const fingerprint = scanResult?.fingerprint || window.knownDiscInfo?.fingerprint;
    if (!fingerprint) {
        alert('No disc fingerprint available');
        return;
    }

    const title = document.getElementById('disc-title').value.trim();
    const year = document.getElementById('disc-year').value.trim();

    if (!title || !year) {
        alert('Please enter title and year');
        return;
    }

    // Auto-generate folder name if empty
    const discFolderInput = document.getElementById('disc-folder');
    if (!discFolderInput.value) {
        discFolderInput.value = generateDiscFolder();
    }

    try {
        const response = await fetch('/api/disc/metadata', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                fingerprint: fingerprint,
                tmdb_id: window.selectedTMDBId || null,
                imdb_id: window.selectedIMDBId || null,
                title: title,
                year: parseInt(year)
            })
        });

        if (response.ok) {
            // Visual feedback
            const btn = document.getElementById('save-disc-info-btn');
            btn.textContent = 'Saved!';
            btn.disabled = true;
            setTimeout(() => {
                btn.textContent = 'Save Disc Info';
                btn.disabled = false;
            }, 2000);
        } else {
            const error = await response.json();
            const errorDetail = Array.isArray(error.detail)
                ? error.detail.map(e => e.msg).join(', ')
                : (error.detail || 'Unknown error');
            alert('Failed to save: ' + errorDetail);
        }
    } catch (error) {
        alert('Failed to save: ' + error.message);
    }
}

function enableSaveButton() {
    const btn = document.getElementById('save-disc-info-btn');
    if (btn) btn.disabled = false;
}

function enableSaveTracksButton() {
    const btn = document.getElementById('save-tracks-btn');
    if (btn) btn.disabled = false;
}

// Save track info (names, types, presets) to database
async function saveTrackInfo() {
    if (!window.currentDiscId) {
        alert('No disc loaded');
        return;
    }

    const tracksData = [];
    document.querySelectorAll('.track-row').forEach(row => {
        const trackId = row.dataset.trackId;
        if (trackId) {
            tracksData.push({
                id: parseInt(trackId),
                track_name: row.querySelector('.track-name-input')?.value || null,
                track_type: row.querySelector('.track-type-select')?.value || null,
                preset_name: row.querySelector('.preset-select')?.value || null,
            });
        }
    });

    if (tracksData.length === 0) {
        alert('No tracks to save');
        return;
    }

    const btn = document.getElementById('save-tracks-btn');
    btn.disabled = true;
    btn.textContent = 'Saving...';

    try {
        const response = await fetch(`/api/disc/${window.currentDiscId}/save`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ disc: {}, tracks: tracksData }),
        });

        if (response.ok) {
            btn.textContent = 'Saved!';
            setTimeout(() => {
                btn.textContent = 'Save Track Info';
                btn.disabled = false;
            }, 2000);
        } else {
            const error = await response.json();
            const errorDetail = Array.isArray(error.detail)
                ? error.detail.map(e => e.msg).join(', ')
                : (error.detail || 'Unknown error');
            alert('Failed to save: ' + errorDetail);
            btn.textContent = 'Save Track Info';
            btn.disabled = false;
        }
    } catch (error) {
        alert('Failed to save: ' + error.message);
        btn.textContent = 'Save Track Info';
        btn.disabled = false;
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
    // Load presets first, then populate dropdowns if scan is already displayed
    await loadPresets();
    checkDiscStatus();
    // In case scan result was cached and displayed before presets loaded
    populateAllPresetDropdowns();
});

// Listen for WebSocket disc events
document.addEventListener('amphigory:disc_event', (e) => {
    const eventType = e.detail?.event;
    if (eventType === 'eject') {
        // Immediately clear UI on eject
        scanResult = null;
        window.knownDiscInfo = null;
        window.currentDiscId = null;
        document.getElementById('tracks-body').innerHTML = '';
        document.getElementById('rip-button').disabled = true;
        updateSelectedCount();
    }
    checkDiscStatus();
});
</script>
{% endblock %}
