{% extends "base.html" %}

{% block title %}Cleanup - Amphigory{% endblock %}

{% block content %}
<div class="cleanup-page">
    <h1>Cleanup</h1>

    <!-- Tabs -->
    <div class="tabs">
        <button class="tab-btn active" onclick="showTab('ripped')">Ripped Files</button>
        <button class="tab-btn" onclick="showTab('transcoded')">Transcoded</button>
    </div>

    <!-- Ripped Tab -->
    <div id="ripped-tab" class="tab-content active">
        <div class="card">
            <div class="section-header">
                <h2>Ripped Folders</h2>
                <button class="btn btn-danger" id="delete-ripped-btn" onclick="deleteSelected('ripped')" disabled>
                    Delete Selected
                </button>
            </div>

            <table class="cleanup-table">
                <thead>
                    <tr>
                        <th class="col-select">
                            <input type="checkbox" id="select-all-ripped" onchange="toggleSelectAll('ripped', this.checked)">
                        </th>
                        <th>Name</th>
                        <th>Size</th>
                        <th>Files</th>
                        <th>Age</th>
                    </tr>
                </thead>
                <tbody id="ripped-list"
                       hx-get="/api/cleanup/ripped/html"
                       hx-trigger="load, refresh from:body"
                       hx-target="#ripped-list">
                    <tr><td colspan="5" class="loading">Loading...</td></tr>
                </tbody>
            </table>

            <div class="selection-footer">
                <span id="ripped-info">No folders selected</span>
            </div>
        </div>
    </div>

    <!-- Transcoded Tab -->
    <div id="transcoded-tab" class="tab-content">
        <div class="card">
            <div class="section-header">
                <h2>Transcoded Folders</h2>
                <div class="action-buttons">
                    <button class="btn btn-primary" id="move-transcoded-btn" onclick="moveSelected()" disabled>
                        Move to Plex
                    </button>
                    <button class="btn btn-danger" id="delete-transcoded-btn" onclick="deleteSelected('transcoded')" disabled>
                        Delete Selected
                    </button>
                </div>
            </div>

            <table class="cleanup-table">
                <thead>
                    <tr>
                        <th class="col-select">
                            <input type="checkbox" id="select-all-transcoded" onchange="toggleSelectAll('transcoded', this.checked)">
                        </th>
                        <th>Name</th>
                        <th>Size</th>
                        <th>Files</th>
                        <th>Age</th>
                    </tr>
                </thead>
                <tbody id="transcoded-list"
                       hx-get="/api/cleanup/transcoded/html"
                       hx-trigger="load, refresh from:body"
                       hx-target="#transcoded-list">
                    <tr><td colspan="5" class="loading">Loading...</td></tr>
                </tbody>
            </table>

            <div class="selection-footer">
                <span id="transcoded-info">No folders selected</span>
            </div>
        </div>
    </div>
</div>

<script>
// Track selected folders for each tab
const selectedFolders = {
    ripped: new Map(), // folderName -> size
    transcoded: new Map(),
};

function showTab(tabName) {
    // Hide all tabs
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Show selected tab
    document.getElementById(`${tabName}-tab`).classList.add('active');
    event.target.classList.add('active');
}

function toggleFolder(checkbox, tab, folderName, size) {
    if (checkbox.checked) {
        selectedFolders[tab].set(folderName, size);
    } else {
        selectedFolders[tab].delete(folderName);
    }
    updateSelectionInfo(tab);
}

function toggleSelectAll(tab, checked) {
    const tbody = document.getElementById(`${tab}-list`);
    const checkboxes = tbody.querySelectorAll('input[type="checkbox"]');

    checkboxes.forEach(checkbox => {
        checkbox.checked = checked;
        const folderName = checkbox.dataset.folder;
        const size = parseInt(checkbox.dataset.size);

        if (checked) {
            selectedFolders[tab].set(folderName, size);
        } else {
            selectedFolders[tab].delete(folderName);
        }
    });

    updateSelectionInfo(tab);
}

function updateSelectionInfo(tab) {
    const selected = selectedFolders[tab];
    const count = selected.size;
    const totalSize = Array.from(selected.values()).reduce((sum, size) => sum + size, 0);

    const infoElement = document.getElementById(`${tab}-info`);
    if (count === 0) {
        infoElement.textContent = 'No folders selected';
    } else {
        infoElement.textContent = `${count} folder${count > 1 ? 's' : ''} selected (${formatSize(totalSize)})`;
    }

    // Update button states
    if (tab === 'ripped') {
        document.getElementById('delete-ripped-btn').disabled = count === 0;
    } else if (tab === 'transcoded') {
        document.getElementById('move-transcoded-btn').disabled = count === 0;
        document.getElementById('delete-transcoded-btn').disabled = count === 0;
    }

    // Update select-all checkbox
    const tbody = document.getElementById(`${tab}-list`);
    const allCheckboxes = tbody.querySelectorAll('input[type="checkbox"]');
    const selectAllCheckbox = document.getElementById(`select-all-${tab}`);
    if (selectAllCheckbox) {
        selectAllCheckbox.checked = allCheckboxes.length > 0 && count === allCheckboxes.length;
    }
}

function formatSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

async function deleteSelected(tab) {
    const selected = selectedFolders[tab];
    if (selected.size === 0) return;

    const folderNames = Array.from(selected.keys());
    const count = folderNames.length;
    const totalSize = Array.from(selected.values()).reduce((sum, size) => sum + size, 0);

    const confirmed = confirm(
        `Delete ${count} folder${count > 1 ? 's' : ''} (${formatSize(totalSize)})?\n\n` +
        `This action cannot be undone!`
    );

    if (!confirmed) return;

    try {
        const endpoint = tab === 'ripped' ? '/api/cleanup/ripped' : '/api/cleanup/transcoded';
        const response = await fetch(endpoint, {
            method: 'DELETE',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({folders: folderNames}),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.errors.length > 0) {
            alert(`Deleted ${result.deleted} folder(s).\n\nErrors:\n${result.errors.join('\n')}`);
        } else {
            alert(`Successfully deleted ${result.deleted} folder(s).`);
        }

        // Clear selection and refresh list
        selectedFolders[tab].clear();
        htmx.trigger('body', 'refresh');

    } catch (error) {
        console.error('Error deleting folders:', error);
        alert('Failed to delete folders. Please try again.');
    }
}

async function moveSelected() {
    const selected = selectedFolders.transcoded;
    if (selected.size === 0) return;

    const folderNames = Array.from(selected.keys());
    const count = folderNames.length;

    const destination = prompt(
        `Move ${count} folder${count > 1 ? 's' : ''} to Plex library?\n\n` +
        `Enter destination: Movies, TV-Shows, or Music`
    );

    if (!destination) return;

    const validDestinations = ['Movies', 'TV-Shows', 'Music'];
    if (!validDestinations.includes(destination)) {
        alert('Invalid destination. Must be: Movies, TV-Shows, or Music');
        return;
    }

    try {
        const response = await fetch('/api/cleanup/transcoded/move', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                folders: folderNames,
                destination: destination,
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.errors.length > 0) {
            alert(`Moved ${result.moved} folder(s) to ${destination}.\n\nErrors:\n${result.errors.join('\n')}`);
        } else {
            alert(`Successfully moved ${result.moved} folder(s) to ${destination}.`);
        }

        // Clear selection and refresh list
        selectedFolders.transcoded.clear();
        htmx.trigger('body', 'refresh');

    } catch (error) {
        console.error('Error moving folders:', error);
        alert('Failed to move folders. Please try again.');
    }
}

// Initialize on load
document.addEventListener('htmx:afterSettle', function(event) {
    // Update selection info after HTMX loads content
    if (event.detail.target.id === 'ripped-list') {
        updateSelectionInfo('ripped');
    } else if (event.detail.target.id === 'transcoded-list') {
        updateSelectionInfo('transcoded');
    }
});
</script>

<style>
.cleanup-page h1 {
    margin-bottom: 1.5rem;
}

/* Tabs */
.tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    border-bottom: 2px solid var(--border);
}

.tab-btn {
    padding: 0.75rem 1.5rem;
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-size: 1rem;
    color: var(--text-muted);
    margin-bottom: -2px;
    transition: all 0.2s;
}

.tab-btn:hover {
    color: var(--text);
}

.tab-btn.active {
    color: var(--primary);
    border-bottom-color: var(--primary);
    font-weight: 500;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Section header */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.section-header h2 {
    margin-bottom: 0;
}

.action-buttons {
    display: flex;
    gap: 0.5rem;
}

/* Cleanup table */
.cleanup-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
}

.cleanup-table th,
.cleanup-table td {
    padding: 0.75rem 0.5rem;
    text-align: left;
    border-bottom: 1px solid var(--border);
}

.cleanup-table th {
    font-weight: 500;
    color: var(--text-muted);
    font-size: 0.8rem;
    text-transform: uppercase;
}

.cleanup-table tbody tr:hover {
    background: var(--bg);
}

.col-select {
    width: 40px;
    text-align: center;
}

.loading {
    text-align: center;
    color: var(--text-muted);
    padding: 2rem;
}

/* Selection footer */
.selection-footer {
    margin-top: 1rem;
    padding: 0.75rem;
    background: var(--bg);
    border-radius: 4px;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.9rem;
}

/* Button styles */
.btn-danger {
    background: var(--error);
    color: white;
}

.btn-danger:hover:not(:disabled) {
    background: #dc2626;
}

.btn-danger:disabled,
.btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
</style>
{% endblock %}
